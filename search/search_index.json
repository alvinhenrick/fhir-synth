{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FHIR Synth","text":"<p>Dynamic FHIR R4B synthetic data generator using LLM-powered code generation and declarative rules.</p> <p>Generate realistic synthetic healthcare data from natural language prompts. Tell it what you want, and it generates the code to create it.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>Your Prompt\n    \u2193\nRules / Code Generation (LLM)\n    \u2193\nFHIR Resources (Patient, Condition, Observation, etc.)\n    \u2193\nFHIR R4B Bundles\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Natural Language \u2192 FHIR: Describe what you need in plain English, get valid FHIR R4B Bundles</li> <li>LLM-Powered Code Generation: Uses GPT-4, Claude, or 100+ providers via LiteLLM</li> <li>Self-Healing Execution: If generated code fails, errors are sent back to the LLM for automatic retry</li> <li>Declarative Rule Engine: Define generation rules as structured data</li> <li>EMPI Support: Generate Person \u2192 Patient linkages across EMR systems</li> <li>Custom Metadata: Add security labels, tags, profiles, and source via YAML config or CLI flags</li> <li>Full FHIR R4B: Supports all 141 R4B resource types via <code>fhir.resources</code> Pydantic models</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Generate 10 diabetic patients with labs\nfhir-synth generate \"10 diabetic patients with HbA1c observations\" -o diabetes.json\n\n# Try without an API key (mock LLM for testing)\nfhir-synth generate \"5 patients\" --provider mock -o test.json\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation \u2014 Set up FHIR Synth</li> <li>Quick Start \u2014 Generate your first data</li> <li>CLI Reference \u2014 All commands and flags</li> <li>Architecture \u2014 System design and data flows</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#system-overview","title":"System Overview","text":"<pre><code>graph TB\n    subgraph UI[\"\ud83d\udda5\ufe0f User Interface\"]\n        CLI[\"CLI (Typer)\\ngenerate \u00b7 rules \u00b7 codegen \u00b7 bundle\"]\n        API[\"Python API\\nCodeGenerator \u00b7 RuleEngine\\nBundleBuilder \u00b7 FHIRResourceFactory\"]\n    end\n\n    subgraph CORE[\"\u2699\ufe0f Core Modules\"]\n        CG[\"code_generator/\\nCodeGenerator \u00b7 PromptToRulesConverter\\nexecutor \u00b7 prompts \u00b7 utils\"]\n        RE[\"rule_engine/\\nRuleEngine \u00b7 Rule \u00b7 RuleSet\\nGenerationRules \u00b7 EMPI\"]\n        BB[\"bundle/\\nBundleBuilder \u00b7 BundleManager\\nBundleFactory\"]\n        FU[\"fhir_utils/\\nFHIRResourceFactory\\nLazyResourceMap\"]\n        FS[\"fhir_spec.py\\nAuto-discovery of all\\n141 R4B resource types\"]\n    end\n\n    subgraph LLM_LAYER[\"\ud83e\udd16 LLM Layer\"]\n        LLM[\"llm.py\\nLLMProvider \u00b7 MockLLMProvider\\nget_provider()\"]\n        LITELLM[\"LiteLLM\\nOpenAI \u00b7 Anthropic \u00b7 Bedrock\\nAzure \u00b7 100+ providers\"]\n    end\n\n    subgraph FHIR[\"\ud83c\udfe5 FHIR Foundation\"]\n        FR[\"fhir.resources (R4B)\\nPydantic models for all\\nFHIR resource types\"]\n    end\n\n    CLI --&gt; CG\n    CLI --&gt; RE\n    CLI --&gt; BB\n    API --&gt; CG\n    API --&gt; RE\n    API --&gt; BB\n    API --&gt; FU\n\n    CG --&gt; LLM\n    CG --&gt; FS\n    RE --&gt; FS\n    BB --&gt; RE\n    BB --&gt; FS\n    FU --&gt; FS\n    LLM --&gt; LITELLM\n    FS --&gt; FR\n    FU --&gt; FR</code></pre>"},{"location":"architecture/#generate-command-data-flow","title":"Generate Command \u2014 Data Flow","text":"<p>The primary workflow: prompt \u2192 LLM \u2192 code \u2192 execute \u2192 FHIR Bundle.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant U as \ud83d\udc64 User\n    participant CLI as \ud83d\udda5\ufe0f CLI\n    participant CG as \u2699\ufe0f CodeGenerator\n    participant LLM as \ud83e\udd16 LLMProvider\n    participant EX as \ud83d\udd12 Sandbox Executor\n    participant BB as \ud83d\udce6 BundleBuilder\n    participant F as \ud83d\udcbe File\n\n    U-&gt;&gt;CLI: fhir-synth generate \"10 diabetic patients\" -o out.json\n    CLI-&gt;&gt;CG: generate_code_from_prompt(prompt)\n    CG-&gt;&gt;LLM: generate_text(system_prompt, user_prompt)\n    LLM--&gt;&gt;CG: Python code (fhir.resources)\n    CG-&gt;&gt;CG: _extract_code() \u2014 strip markdown fences\n    CG--&gt;&gt;CLI: code string\n\n    CLI-&gt;&gt;CG: execute_generated_code(code)\n    CG-&gt;&gt;CG: validate_code() \u2014 compile check\n    CG-&gt;&gt;EX: exec(code) \u2192 generate_resources()\n\n    alt \u274c Execution fails\n        EX--&gt;&gt;CG: error / traceback\n        CG-&gt;&gt;LLM: _retry_with_error(code, error)\n        LLM--&gt;&gt;CG: fixed code\n        CG-&gt;&gt;EX: exec(fixed_code)\n    end\n\n    EX--&gt;&gt;CG: list[dict] resources\n    CG--&gt;&gt;CLI: resources\n\n    CLI-&gt;&gt;BB: add_resources(resources)\n    CLI-&gt;&gt;BB: build()\n    BB--&gt;&gt;CLI: FHIR Bundle dict\n\n    CLI-&gt;&gt;F: write JSON\n    CLI--&gt;&gt;U: \u2713 Bundle with N entries \u2192 out.json</code></pre>"},{"location":"architecture/#self-healing-code-execution","title":"Self-Healing Code Execution","text":"<p>When LLM-generated code fails, the error is automatically sent back to the LLM for correction (up to 2 retries).</p> <pre><code>flowchart TD\n    A[\"\ud83e\udd16 LLM generates Python code\"] --&gt; B{\"\u2705 Syntax valid?\"}\n    B --&gt;|No| C[\"\ud83d\udce4 Send error to LLM\"]\n    B --&gt;|Yes| D[\"\ud83d\udd12 Execute in sandbox\"]\n    D --&gt; E{\"\u2705 Execution succeeds?\"}\n    E --&gt;|Yes| F[\"\u2713 Return resources\"]\n    E --&gt;|No| G{\"\ud83d\udd04 Retries left?\"}\n    G --&gt;|\"Yes (max 2)\"| C\n    G --&gt;|No| H[\"\u2717 Raise RuntimeError\"]\n    C --&gt; I[\"\ud83e\udd16 LLM returns fixed code\"]\n    I --&gt; B</code></pre>"},{"location":"architecture/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"architecture/#llm-integration-via-litellm","title":"LLM Integration via LiteLLM","text":"<p>All LLM calls go through a thin <code>LLMProvider</code> abstraction backed by LiteLLM, supporting 100+ providers (OpenAI, Anthropic, Bedrock, Azure, etc.) with a single interface. A <code>MockLLMProvider</code> enables testing without API keys.</p>"},{"location":"architecture/#fhir-spec-auto-discovery","title":"FHIR Spec Auto-Discovery","text":"<p>At import time, <code>fhir_spec.py</code> scans the <code>fhir.resources.R4B</code> package filesystem and builds a <code>{ClassName: module}</code> map of all ~141 resource types. Actual classes are loaded lazily on first access via <code>get_resource_class()</code>, keeping startup fast.</p>"},{"location":"architecture/#custom-metadata","title":"Custom Metadata","text":"<p>Metadata (security labels, tags, profiles, source) can be applied at two levels:</p> <ul> <li>Global (<code>RuleSet.global_meta</code>) \u2014 applied to all resources from that ruleset</li> <li>Per-rule (<code>Rule.meta</code>) \u2014 merged on top of global, with rule-specific values taking precedence</li> </ul> <p>For CLI usage, metadata is configured via a simple YAML file passed with <code>--meta-config</code>:</p> <pre><code>meta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"N\"\n      display: \"Normal\"\n  tag:\n    - system: \"http://example.org/tags\"\n      code: \"synthetic-data\"\n  source: \"http://example.org/fhir-synth\"\n</code></pre>"},{"location":"architecture/#sandboxed-execution","title":"Sandboxed Execution","text":"<p>Generated Python code runs in a restricted <code>exec()</code> sandbox with controlled builtins. The code must define a <code>generate_resources()</code> function that returns a list of FHIR resource dicts.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p> <p>Releases are managed automatically by python-semantic-release.</p>"},{"location":"changelog/#010-2026-02-24","title":"[0.1.0] - 2026-02-24","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release</li> <li>LLM-powered FHIR R4B code generation with self-healing execution</li> <li>Declarative rule engine with weighted rule selection</li> <li>EMPI (Person \u2192 Patient) linkage support</li> <li>Bundle builder with transaction/batch/collection support</li> <li>Custom metadata support (security labels, tags, profiles, source)</li> <li>YAML-based metadata configuration</li> <li>CLI commands: <code>generate</code>, <code>rules</code>, <code>codegen</code>, <code>bundle</code></li> <li>Mock LLM provider for testing without API keys</li> <li>Support for 100+ LLM providers via LiteLLM</li> <li>Auto-discovery of all 141 FHIR R4B resource types</li> </ul>"},{"location":"api/bundle/","title":"Bundle","text":""},{"location":"api/bundle/#fhir_synth.bundle","title":"<code>fhir_synth.bundle</code>","text":"<p>FHIR Bundle creation and management.</p>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder","title":"<code>BundleBuilder</code>","text":"<p>Build FHIR Bundles from generated resources.</p> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>class BundleBuilder:\n    \"\"\"Build FHIR Bundles from generated resources.\"\"\"\n\n    def __init__(self, bundle_type: str = \"transaction\") -&gt; None:\n        \"\"\"Initialize bundle builder.\n\n        Args:\n            bundle_type: Type of bundle (transaction, batch, searchset, collection, etc.)\n        \"\"\"\n        self.bundle_type = bundle_type\n        self.entries: list[dict[str, Any]] = []\n\n    def add_resource(\n        self,\n        resource: dict[str, Any],\n        method: str = \"POST\",\n        url: str | None = None,\n    ) -&gt; None:\n        \"\"\"Add a resource to the bundle.\n\n        Args:\n            resource: FHIR resource dictionary\n            method: HTTP method (POST, PUT, DELETE, GET)\n            url: Target URL for the request (auto-generated if not provided)\n        \"\"\"\n        resource_type = resource.get(\"resourceType\")\n        resource_id = resource.get(\"id\")\n\n        if url is None:\n            url = f\"{resource_type}\" + (f\"/{resource_id}\" if resource_id else \"\")\n\n        entry = {\n            \"fullUrl\": f\"urn:uuid:{resource_id or self._generate_id()}\",\n            \"resource\": resource,\n            \"request\": {\n                \"method\": method,\n                \"url\": url,\n            },\n        }\n\n        self.entries.append(entry)\n\n    def add_resources(\n        self,\n        resources: list[dict[str, Any]],\n        method: str = \"POST\",\n    ) -&gt; None:\n        \"\"\"Add multiple resources to the bundle.\n\n        Args:\n            resources: List of FHIR resource dictionaries\n            method: HTTP method for all resources\n        \"\"\"\n        for resource in resources:\n            self.add_resource(resource, method)\n\n    def build(self) -&gt; dict[str, Any]:\n        \"\"\"Build and return the bundle.\n\n        Returns:\n            Complete FHIR Bundle resource\n        \"\"\"\n        bundle = {\n            \"resourceType\": \"Bundle\",\n            \"id\": self._generate_id(),\n            \"type\": self.bundle_type,\n            \"timestamp\": self._current_timestamp(),\n            \"total\": len(self.entries),\n            \"entry\": self.entries,\n        }\n\n        return bundle\n\n    def build_with_relationships(\n        self,\n        resources_by_type: dict[str, list[dict[str, Any]]],\n    ) -&gt; dict[str, Any]:\n        \"\"\"Build a bundle with automatic reference linking between resources.\n\n        Args:\n            resources_by_type: Dict mapping resource type to list of resources\n\n        Returns:\n            Bundle with established references\n        \"\"\"\n        # Create a references map\n        references: dict[str, list[str]] = {}\n        for resource_type, resources in resources_by_type.items():\n            references[resource_type] = [\n                str(rid) for r in resources if (rid := r.get(\"id\")) is not None\n            ]\n\n        # Add resources and establish relationships\n        for resource_type, resources in resources_by_type.items():\n            for resource in resources:\n                self._add_resource_with_refs(resource, references, resource_type)\n\n        return self.build()\n\n    def _add_resource_with_refs(\n        self,\n        resource: dict[str, Any],\n        references: dict[str, list[str]],\n        primary_type: str,\n    ) -&gt; None:\n        \"\"\"Add resource and inject references where appropriate.\n\n        Uses ``fhir_spec.reference_targets`` to discover which fields on\n        *primary_type* accept references, then auto-links to Patient (or\n        other available resources) if IDs exist.\n        \"\"\"\n        if primary_type != \"Patient\" and \"Patient\" in references and references[\"Patient\"]:\n            patient_id = references[\"Patient\"][0]\n            # Check if this resource type has subject/patient reference fields\n            try:\n                ref_fields = reference_targets(primary_type)\n                for ref_field in _PATIENT_REF_FIELDS:\n                    if ref_field in ref_fields and ref_field not in resource:\n                        resource[ref_field] = {\"reference\": f\"Patient/{patient_id}\"}\n                        break\n            except ValueError:\n                pass\n\n        self.add_resource(resource)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all entries from builder.\"\"\"\n        self.entries = []\n\n    @staticmethod\n    def _generate_id() -&gt; str:\n        \"\"\"Generate a unique ID.\"\"\"\n        return str(uuid.uuid4())\n\n    @staticmethod\n    def _current_timestamp() -&gt; str:\n        \"\"\"Get the current timestamp in ISO format.\"\"\"\n        return datetime.now(UTC).isoformat() + \"Z\"\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder.__init__","title":"<code>__init__(bundle_type='transaction')</code>","text":"<p>Initialize bundle builder.</p> <p>Parameters:</p> Name Type Description Default <code>bundle_type</code> <code>str</code> <p>Type of bundle (transaction, batch, searchset, collection, etc.)</p> <code>'transaction'</code> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>def __init__(self, bundle_type: str = \"transaction\") -&gt; None:\n    \"\"\"Initialize bundle builder.\n\n    Args:\n        bundle_type: Type of bundle (transaction, batch, searchset, collection, etc.)\n    \"\"\"\n    self.bundle_type = bundle_type\n    self.entries: list[dict[str, Any]] = []\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder.add_resource","title":"<code>add_resource(resource, method='POST', url=None)</code>","text":"<p>Add a resource to the bundle.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>dict[str, Any]</code> <p>FHIR resource dictionary</p> required <code>method</code> <code>str</code> <p>HTTP method (POST, PUT, DELETE, GET)</p> <code>'POST'</code> <code>url</code> <code>str | None</code> <p>Target URL for the request (auto-generated if not provided)</p> <code>None</code> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>def add_resource(\n    self,\n    resource: dict[str, Any],\n    method: str = \"POST\",\n    url: str | None = None,\n) -&gt; None:\n    \"\"\"Add a resource to the bundle.\n\n    Args:\n        resource: FHIR resource dictionary\n        method: HTTP method (POST, PUT, DELETE, GET)\n        url: Target URL for the request (auto-generated if not provided)\n    \"\"\"\n    resource_type = resource.get(\"resourceType\")\n    resource_id = resource.get(\"id\")\n\n    if url is None:\n        url = f\"{resource_type}\" + (f\"/{resource_id}\" if resource_id else \"\")\n\n    entry = {\n        \"fullUrl\": f\"urn:uuid:{resource_id or self._generate_id()}\",\n        \"resource\": resource,\n        \"request\": {\n            \"method\": method,\n            \"url\": url,\n        },\n    }\n\n    self.entries.append(entry)\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder.add_resources","title":"<code>add_resources(resources, method='POST')</code>","text":"<p>Add multiple resources to the bundle.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>list[dict[str, Any]]</code> <p>List of FHIR resource dictionaries</p> required <code>method</code> <code>str</code> <p>HTTP method for all resources</p> <code>'POST'</code> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>def add_resources(\n    self,\n    resources: list[dict[str, Any]],\n    method: str = \"POST\",\n) -&gt; None:\n    \"\"\"Add multiple resources to the bundle.\n\n    Args:\n        resources: List of FHIR resource dictionaries\n        method: HTTP method for all resources\n    \"\"\"\n    for resource in resources:\n        self.add_resource(resource, method)\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder.build","title":"<code>build()</code>","text":"<p>Build and return the bundle.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Complete FHIR Bundle resource</p> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>def build(self) -&gt; dict[str, Any]:\n    \"\"\"Build and return the bundle.\n\n    Returns:\n        Complete FHIR Bundle resource\n    \"\"\"\n    bundle = {\n        \"resourceType\": \"Bundle\",\n        \"id\": self._generate_id(),\n        \"type\": self.bundle_type,\n        \"timestamp\": self._current_timestamp(),\n        \"total\": len(self.entries),\n        \"entry\": self.entries,\n    }\n\n    return bundle\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder.build_with_relationships","title":"<code>build_with_relationships(resources_by_type)</code>","text":"<p>Build a bundle with automatic reference linking between resources.</p> <p>Parameters:</p> Name Type Description Default <code>resources_by_type</code> <code>dict[str, list[dict[str, Any]]]</code> <p>Dict mapping resource type to list of resources</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Bundle with established references</p> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>def build_with_relationships(\n    self,\n    resources_by_type: dict[str, list[dict[str, Any]]],\n) -&gt; dict[str, Any]:\n    \"\"\"Build a bundle with automatic reference linking between resources.\n\n    Args:\n        resources_by_type: Dict mapping resource type to list of resources\n\n    Returns:\n        Bundle with established references\n    \"\"\"\n    # Create a references map\n    references: dict[str, list[str]] = {}\n    for resource_type, resources in resources_by_type.items():\n        references[resource_type] = [\n            str(rid) for r in resources if (rid := r.get(\"id\")) is not None\n        ]\n\n    # Add resources and establish relationships\n    for resource_type, resources in resources_by_type.items():\n        for resource in resources:\n            self._add_resource_with_refs(resource, references, resource_type)\n\n    return self.build()\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleBuilder.clear","title":"<code>clear()</code>","text":"<p>Clear all entries from builder.</p> Source code in <code>src/fhir_synth/bundle/builder.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all entries from builder.\"\"\"\n    self.entries = []\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory","title":"<code>BundleFactory</code>","text":"<p>Factory for building FHIR Bundles with Pydantic model resources.</p> <p>This class bridges Pydantic models with the bundle builder, automatically converting models to dicts.</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>class BundleFactory:\n    \"\"\"Factory for building FHIR Bundles with Pydantic model resources.\n\n    This class bridges Pydantic models with the bundle builder,\n    automatically converting models to dicts.\n    \"\"\"\n\n    def __init__(self, bundle_type: str = \"transaction\") -&gt; None:\n        \"\"\"Initialize bundle factory.\n\n        Args:\n            bundle_type: Type of bundle to create\n        \"\"\"\n        self.bundle_type = bundle_type\n        self.entries: list[dict[str, Any]] = []\n\n    def add_resource(\n        self,\n        resource: BaseModel | dict[str, Any],\n        method: str = \"POST\",\n    ) -&gt; None:\n        \"\"\"Add a resource to the bundle.\n\n        Args:\n            resource: FHIR resource (Pydantic model or dict)\n            method: HTTP method (POST, PUT, DELETE, GET)\n        \"\"\"\n        # Convert Pydantic model to dict if needed\n        if isinstance(resource, BaseModel):\n            resource_dict = resource.model_dump(exclude_none=True, by_alias=True)\n        else:\n            resource_dict = resource\n\n        resource_type = resource_dict.get(\"resourceType\")\n        resource_id = resource_dict.get(\"id\")\n\n        url = f\"{resource_type}\" + (f\"/{resource_id}\" if resource_id else \"\")\n\n        entry = {\n            \"fullUrl\": f\"urn:uuid:{resource_id}\",\n            \"resource\": resource_dict,\n            \"request\": {\n                \"method\": method,\n                \"url\": url,\n            },\n        }\n        self.entries.append(entry)\n\n    def add_resources(\n        self,\n        resources: list[BaseModel | dict[str, Any]],\n        method: str = \"POST\",\n    ) -&gt; None:\n        \"\"\"Add multiple resources to the bundle.\n\n        Args:\n            resources: List of FHIR resources\n            method: HTTP method for all resources\n        \"\"\"\n        for resource in resources:\n            self.add_resource(resource, method)\n\n    def build(self) -&gt; dict[str, Any]:\n        \"\"\"Build the FHIR Bundle as a dictionary.\n\n        Returns:\n            Complete FHIR Bundle resource as dict\n        \"\"\"\n        import uuid\n        from datetime import UTC, datetime\n\n        return {\n            \"resourceType\": \"Bundle\",\n            \"id\": str(uuid.uuid4()),\n            \"type\": self.bundle_type,\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"total\": len(self.entries),\n            \"entry\": self.entries,\n        }\n\n    def build_pydantic(self) -&gt; BaseModel:\n        \"\"\"Build the bundle and return as Pydantic model.\n\n        Returns:\n            Bundle as a Pydantic model\n        \"\"\"\n        from fhir_synth.fhir_spec import get_resource_class\n\n        bundle_dict = self.build()\n        bundle_class = get_resource_class(\"Bundle\")\n        return bundle_class(**bundle_dict)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all entries.\"\"\"\n        self.entries = []\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory.__init__","title":"<code>__init__(bundle_type='transaction')</code>","text":"<p>Initialize bundle factory.</p> <p>Parameters:</p> Name Type Description Default <code>bundle_type</code> <code>str</code> <p>Type of bundle to create</p> <code>'transaction'</code> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def __init__(self, bundle_type: str = \"transaction\") -&gt; None:\n    \"\"\"Initialize bundle factory.\n\n    Args:\n        bundle_type: Type of bundle to create\n    \"\"\"\n    self.bundle_type = bundle_type\n    self.entries: list[dict[str, Any]] = []\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory.add_resource","title":"<code>add_resource(resource, method='POST')</code>","text":"<p>Add a resource to the bundle.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>BaseModel | dict[str, Any]</code> <p>FHIR resource (Pydantic model or dict)</p> required <code>method</code> <code>str</code> <p>HTTP method (POST, PUT, DELETE, GET)</p> <code>'POST'</code> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def add_resource(\n    self,\n    resource: BaseModel | dict[str, Any],\n    method: str = \"POST\",\n) -&gt; None:\n    \"\"\"Add a resource to the bundle.\n\n    Args:\n        resource: FHIR resource (Pydantic model or dict)\n        method: HTTP method (POST, PUT, DELETE, GET)\n    \"\"\"\n    # Convert Pydantic model to dict if needed\n    if isinstance(resource, BaseModel):\n        resource_dict = resource.model_dump(exclude_none=True, by_alias=True)\n    else:\n        resource_dict = resource\n\n    resource_type = resource_dict.get(\"resourceType\")\n    resource_id = resource_dict.get(\"id\")\n\n    url = f\"{resource_type}\" + (f\"/{resource_id}\" if resource_id else \"\")\n\n    entry = {\n        \"fullUrl\": f\"urn:uuid:{resource_id}\",\n        \"resource\": resource_dict,\n        \"request\": {\n            \"method\": method,\n            \"url\": url,\n        },\n    }\n    self.entries.append(entry)\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory.add_resources","title":"<code>add_resources(resources, method='POST')</code>","text":"<p>Add multiple resources to the bundle.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>list[BaseModel | dict[str, Any]]</code> <p>List of FHIR resources</p> required <code>method</code> <code>str</code> <p>HTTP method for all resources</p> <code>'POST'</code> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def add_resources(\n    self,\n    resources: list[BaseModel | dict[str, Any]],\n    method: str = \"POST\",\n) -&gt; None:\n    \"\"\"Add multiple resources to the bundle.\n\n    Args:\n        resources: List of FHIR resources\n        method: HTTP method for all resources\n    \"\"\"\n    for resource in resources:\n        self.add_resource(resource, method)\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory.build","title":"<code>build()</code>","text":"<p>Build the FHIR Bundle as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Complete FHIR Bundle resource as dict</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def build(self) -&gt; dict[str, Any]:\n    \"\"\"Build the FHIR Bundle as a dictionary.\n\n    Returns:\n        Complete FHIR Bundle resource as dict\n    \"\"\"\n    import uuid\n    from datetime import UTC, datetime\n\n    return {\n        \"resourceType\": \"Bundle\",\n        \"id\": str(uuid.uuid4()),\n        \"type\": self.bundle_type,\n        \"timestamp\": datetime.now(UTC).isoformat(),\n        \"total\": len(self.entries),\n        \"entry\": self.entries,\n    }\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory.build_pydantic","title":"<code>build_pydantic()</code>","text":"<p>Build the bundle and return as Pydantic model.</p> <p>Returns:</p> Type Description <code>BaseModel</code> <p>Bundle as a Pydantic model</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def build_pydantic(self) -&gt; BaseModel:\n    \"\"\"Build the bundle and return as Pydantic model.\n\n    Returns:\n        Bundle as a Pydantic model\n    \"\"\"\n    from fhir_synth.fhir_spec import get_resource_class\n\n    bundle_dict = self.build()\n    bundle_class = get_resource_class(\"Bundle\")\n    return bundle_class(**bundle_dict)\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleFactory.clear","title":"<code>clear()</code>","text":"<p>Clear all entries.</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all entries.\"\"\"\n    self.entries = []\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleManager","title":"<code>BundleManager</code>","text":"<p>Manage creation and validation of FHIR Bundles.</p> Source code in <code>src/fhir_synth/bundle/manager.py</code> <pre><code>class BundleManager:\n    \"\"\"Manage creation and validation of FHIR Bundles.\"\"\"\n\n    def __init__(self, rule_engine: RuleEngine | None = None) -&gt; None:\n        \"\"\"Initialize bundle manager.\n\n        Args:\n            rule_engine: Optional RuleEngine for rule-based generation\n        \"\"\"\n        self.rule_engine = rule_engine or RuleEngine()\n\n    def create_bundle_from_rules(\n        self,\n        rules: dict[str, Any],\n        context: dict[str, Any],\n        bundle_type: str = \"transaction\",\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a bundle by executing rules.\n\n        Args:\n            rules: Rules configuration\n            context: Generation context\n            bundle_type: Type of bundle to create\n\n        Returns:\n            Generated FHIR Bundle\n        \"\"\"\n        builder = BundleBuilder(bundle_type=bundle_type)\n\n        # Execute each rule type\n        for _rule_key, rule_config in rules.items():\n            if isinstance(rule_config, dict) and \"count\" in rule_config:\n                resource_type = rule_config.get(\"resourceType\")\n                count = rule_config.get(\"count\", 1)\n\n                if resource_type in self.rule_engine.rulesets:\n                    resources = self.rule_engine.execute(resource_type, context, count)\n                    builder.add_resources(resources)\n\n        return builder.build()\n\n    def create_multi_patient_bundle(\n        self,\n        patient_count: int = 5,\n        resources_per_patient: dict[str, int] | None = None,\n        bundle_type: str = \"transaction\",\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a bundle with multiple patients and associated resources.\n\n        Args:\n            patient_count: Number of patients to generate\n            resources_per_patient: Count of each resource type per patient\n                Example: {\"Condition\": 2, \"Medication\": 3}\n            bundle_type: Type of bundle to create\n\n        Returns:\n            FHIR Bundle with patients and related resources\n        \"\"\"\n        if resources_per_patient is None:\n            resources_per_patient = {\"Condition\": 1, \"Observation\": 2}\n\n        builder = BundleBuilder(bundle_type=bundle_type)\n        patients = []\n\n        # Generate patients\n        if \"Patient\" in self.rule_engine.rulesets:\n            patients = self.rule_engine.execute(\"Patient\", {}, patient_count)\n            builder.add_resources(patients)\n\n        # Generate related resources\n        for patient in patients:\n            patient_id = patient.get(\"id\")\n            if patient_id is None:\n                continue\n            patient_id_str = str(patient_id)\n            context: dict[str, Any] = {\"patient_id\": patient_id_str}\n\n            for resource_type, count in resources_per_patient.items():\n                if resource_type in self.rule_engine.rulesets:\n                    resources = self.rule_engine.execute(resource_type, context, count)\n\n                    # Inject patient reference\n                    for resource in resources:\n                        self._add_patient_reference(resource, patient_id_str)\n\n                    builder.add_resources(resources)\n\n        return builder.build()\n\n    @staticmethod\n    def _add_patient_reference(resource: dict[str, Any], patient_id: str) -&gt; None:\n        \"\"\"Add patient reference to a resource.\n\n        Uses ``fhir_spec.reference_targets`` to discover if the resource\n        type has a ``subject`` or ``patient`` field that accepts a reference.\n        \"\"\"\n        rt = resource.get(\"resourceType\", \"\")\n        try:\n            ref_fields = reference_targets(rt)\n            for ref_field in _PATIENT_REF_FIELDS:\n                if ref_field in ref_fields:\n                    resource[ref_field] = {\"reference\": f\"Patient/{patient_id}\"}\n                    break\n        except ValueError:\n            pass\n\n    # noinspection PyMethodMayBeStatic\n    def validate_bundle(self, bundle: dict[str, Any]) -&gt; tuple[bool, list[str]]:\n        \"\"\"Validate bundle structure.\n\n        Args:\n            bundle: Bundle to validate\n\n        Returns:\n            Tuple of (is_valid, list_of_errors)\n        \"\"\"\n        errors = []\n\n        # Check required fields\n        if bundle.get(\"resourceType\") != \"Bundle\":\n            errors.append(\"Bundle must have resourceType='Bundle'\")\n\n        if \"type\" not in bundle:\n            errors.append(\"Bundle must have a type\")\n\n        if \"entry\" not in bundle:\n            errors.append(\"Bundle must have entries\")\n\n        # Check entries\n        for i, entry in enumerate(bundle.get(\"entry\", [])):\n            if \"resource\" not in entry:\n                errors.append(f\"Entry {i} missing 'resource'\")\n            else:\n                resource = entry[\"resource\"]\n                if \"resourceType\" not in resource:\n                    errors.append(f\"Entry {i} resource missing 'resourceType'\")\n\n        return len(errors) == 0, errors\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleManager.__init__","title":"<code>__init__(rule_engine=None)</code>","text":"<p>Initialize bundle manager.</p> <p>Parameters:</p> Name Type Description Default <code>rule_engine</code> <code>RuleEngine | None</code> <p>Optional RuleEngine for rule-based generation</p> <code>None</code> Source code in <code>src/fhir_synth/bundle/manager.py</code> <pre><code>def __init__(self, rule_engine: RuleEngine | None = None) -&gt; None:\n    \"\"\"Initialize bundle manager.\n\n    Args:\n        rule_engine: Optional RuleEngine for rule-based generation\n    \"\"\"\n    self.rule_engine = rule_engine or RuleEngine()\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleManager.create_bundle_from_rules","title":"<code>create_bundle_from_rules(rules, context, bundle_type='transaction')</code>","text":"<p>Create a bundle by executing rules.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>dict[str, Any]</code> <p>Rules configuration</p> required <code>context</code> <code>dict[str, Any]</code> <p>Generation context</p> required <code>bundle_type</code> <code>str</code> <p>Type of bundle to create</p> <code>'transaction'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Generated FHIR Bundle</p> Source code in <code>src/fhir_synth/bundle/manager.py</code> <pre><code>def create_bundle_from_rules(\n    self,\n    rules: dict[str, Any],\n    context: dict[str, Any],\n    bundle_type: str = \"transaction\",\n) -&gt; dict[str, Any]:\n    \"\"\"Create a bundle by executing rules.\n\n    Args:\n        rules: Rules configuration\n        context: Generation context\n        bundle_type: Type of bundle to create\n\n    Returns:\n        Generated FHIR Bundle\n    \"\"\"\n    builder = BundleBuilder(bundle_type=bundle_type)\n\n    # Execute each rule type\n    for _rule_key, rule_config in rules.items():\n        if isinstance(rule_config, dict) and \"count\" in rule_config:\n            resource_type = rule_config.get(\"resourceType\")\n            count = rule_config.get(\"count\", 1)\n\n            if resource_type in self.rule_engine.rulesets:\n                resources = self.rule_engine.execute(resource_type, context, count)\n                builder.add_resources(resources)\n\n    return builder.build()\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleManager.create_multi_patient_bundle","title":"<code>create_multi_patient_bundle(patient_count=5, resources_per_patient=None, bundle_type='transaction')</code>","text":"<p>Create a bundle with multiple patients and associated resources.</p> <p>Parameters:</p> Name Type Description Default <code>patient_count</code> <code>int</code> <p>Number of patients to generate</p> <code>5</code> <code>resources_per_patient</code> <code>dict[str, int] | None</code> <p>Count of each resource type per patient Example: {\"Condition\": 2, \"Medication\": 3}</p> <code>None</code> <code>bundle_type</code> <code>str</code> <p>Type of bundle to create</p> <code>'transaction'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>FHIR Bundle with patients and related resources</p> Source code in <code>src/fhir_synth/bundle/manager.py</code> <pre><code>def create_multi_patient_bundle(\n    self,\n    patient_count: int = 5,\n    resources_per_patient: dict[str, int] | None = None,\n    bundle_type: str = \"transaction\",\n) -&gt; dict[str, Any]:\n    \"\"\"Create a bundle with multiple patients and associated resources.\n\n    Args:\n        patient_count: Number of patients to generate\n        resources_per_patient: Count of each resource type per patient\n            Example: {\"Condition\": 2, \"Medication\": 3}\n        bundle_type: Type of bundle to create\n\n    Returns:\n        FHIR Bundle with patients and related resources\n    \"\"\"\n    if resources_per_patient is None:\n        resources_per_patient = {\"Condition\": 1, \"Observation\": 2}\n\n    builder = BundleBuilder(bundle_type=bundle_type)\n    patients = []\n\n    # Generate patients\n    if \"Patient\" in self.rule_engine.rulesets:\n        patients = self.rule_engine.execute(\"Patient\", {}, patient_count)\n        builder.add_resources(patients)\n\n    # Generate related resources\n    for patient in patients:\n        patient_id = patient.get(\"id\")\n        if patient_id is None:\n            continue\n        patient_id_str = str(patient_id)\n        context: dict[str, Any] = {\"patient_id\": patient_id_str}\n\n        for resource_type, count in resources_per_patient.items():\n            if resource_type in self.rule_engine.rulesets:\n                resources = self.rule_engine.execute(resource_type, context, count)\n\n                # Inject patient reference\n                for resource in resources:\n                    self._add_patient_reference(resource, patient_id_str)\n\n                builder.add_resources(resources)\n\n    return builder.build()\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.BundleManager.validate_bundle","title":"<code>validate_bundle(bundle)</code>","text":"<p>Validate bundle structure.</p> <p>Parameters:</p> Name Type Description Default <code>bundle</code> <code>dict[str, Any]</code> <p>Bundle to validate</p> required <p>Returns:</p> Type Description <code>tuple[bool, list[str]]</code> <p>Tuple of (is_valid, list_of_errors)</p> Source code in <code>src/fhir_synth/bundle/manager.py</code> <pre><code>def validate_bundle(self, bundle: dict[str, Any]) -&gt; tuple[bool, list[str]]:\n    \"\"\"Validate bundle structure.\n\n    Args:\n        bundle: Bundle to validate\n\n    Returns:\n        Tuple of (is_valid, list_of_errors)\n    \"\"\"\n    errors = []\n\n    # Check required fields\n    if bundle.get(\"resourceType\") != \"Bundle\":\n        errors.append(\"Bundle must have resourceType='Bundle'\")\n\n    if \"type\" not in bundle:\n        errors.append(\"Bundle must have a type\")\n\n    if \"entry\" not in bundle:\n        errors.append(\"Bundle must have entries\")\n\n    # Check entries\n    for i, entry in enumerate(bundle.get(\"entry\", [])):\n        if \"resource\" not in entry:\n            errors.append(f\"Entry {i} missing 'resource'\")\n        else:\n            resource = entry[\"resource\"]\n            if \"resourceType\" not in resource:\n                errors.append(f\"Entry {i} resource missing 'resourceType'\")\n\n    return len(errors) == 0, errors\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.split_resources_by_patient","title":"<code>split_resources_by_patient(resources)</code>","text":"<p>Split a flat resource list into one Bundle per patient.</p> <p>Each bundle contains the Patient resource plus all resources that reference that patient.  Resources that cannot be linked to any patient (e.g. Organization, Practitioner) are included in every patient bundle, so each bundle is self-contained.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of FHIR Bundle dicts (<code>type: collection</code>).</p> Source code in <code>src/fhir_synth/bundle/splitter.py</code> <pre><code>def split_resources_by_patient(\n    resources: list[dict[str, Any]],\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Split a flat resource list into one Bundle per patient.\n\n    Each bundle contains the Patient resource plus all resources that\n    reference that patient.  Resources that cannot be linked to any\n    patient (e.g. Organization, Practitioner) are included in **every**\n    patient bundle, so each bundle is self-contained.\n\n    Returns:\n        List of FHIR Bundle dicts (``type: collection``).\n    \"\"\"\n    patient_ids: list[str] = []\n    patient_resources: dict[str, list[dict[str, Any]]] = {}\n    unlinked: list[dict[str, Any]] = []\n\n    # First pass \u2014 collect Patient resources (preserving order)\n    for r in resources:\n        if r.get(\"resourceType\") == \"Patient\":\n            pid = r.get(\"id\", f\"unknown-{len(patient_ids)}\")\n            if pid not in patient_resources:\n                patient_ids.append(pid)\n                patient_resources[pid] = []\n            patient_resources[pid].append(r)\n\n    # Second pass \u2014 assign non-Patient resources to their patient\n    for r in resources:\n        if r.get(\"resourceType\") == \"Patient\":\n            continue\n        pid = _extract_patient_id(r)\n        if pid and pid in patient_resources:\n            patient_resources[pid].append(r)\n        else:\n            unlinked.append(r)\n\n    # Build one Bundle per patient\n    bundles: list[dict[str, Any]] = []\n    for pid in patient_ids:\n        entries = patient_resources[pid] + unlinked\n        bundles.append(\n            {\n                \"resourceType\": \"Bundle\",\n                \"type\": \"collection\",\n                \"total\": len(entries),\n                \"entry\": [{\"resource\": r} for r in entries],\n            }\n        )\n\n    # Edge case: no patients found \u2014 return everything in one bundle\n    if not bundles and resources:\n        bundles.append(\n            {\n                \"resourceType\": \"Bundle\",\n                \"type\": \"collection\",\n                \"total\": len(resources),\n                \"entry\": [{\"resource\": r} for r in resources],\n            }\n        )\n\n    return bundles\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.write_ndjson","title":"<code>write_ndjson(bundles, output_path)</code>","text":"<p>Write bundles as NDJSON \u2014 one JSON bundle per line.</p> Source code in <code>src/fhir_synth/bundle/splitter.py</code> <pre><code>def write_ndjson(\n    bundles: list[dict[str, Any]],\n    output_path: Path,\n) -&gt; Path:\n    \"\"\"Write bundles as NDJSON \u2014 one JSON bundle per line.\"\"\"\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    with output_path.open(\"w\") as f:\n        for bundle in bundles:\n            f.write(json.dumps(bundle, default=str) + \"\\n\")\n    return output_path\n</code></pre>"},{"location":"api/bundle/#fhir_synth.bundle.write_split_bundles","title":"<code>write_split_bundles(bundles, output_dir)</code>","text":"<p>Write each patient bundle to a separate JSON file.</p> <p>Files are named <code>patient_001.json</code>, <code>patient_002.json</code>, etc.</p> Source code in <code>src/fhir_synth/bundle/splitter.py</code> <pre><code>def write_split_bundles(\n    bundles: list[dict[str, Any]],\n    output_dir: Path,\n) -&gt; list[Path]:\n    \"\"\"Write each patient bundle to a separate JSON file.\n\n    Files are named ``patient_001.json``, ``patient_002.json``, etc.\n    \"\"\"\n    output_dir.mkdir(parents=True, exist_ok=True)\n    paths: list[Path] = []\n    for i, bundle in enumerate(bundles, 1):\n        path = output_dir / f\"patient_{i:03d}.json\"\n        path.write_text(json.dumps(bundle, indent=2, default=str))\n        paths.append(path)\n    return paths\n</code></pre>"},{"location":"api/code_generator/","title":"Code Generator","text":""},{"location":"api/code_generator/#fhir_synth.code_generator","title":"<code>fhir_synth.code_generator</code>","text":"<p>Dynamic code generation for FHIR resources from LLM prompts.</p>"},{"location":"api/code_generator/#fhir_synth.code_generator.PromptToRulesConverter","title":"<code>PromptToRulesConverter</code>","text":"<p>Convert natural language prompts to declarative rules.</p> Source code in <code>src/fhir_synth/code_generator/converter.py</code> <pre><code>class PromptToRulesConverter:\n    \"\"\"Convert natural language prompts to declarative rules.\"\"\"\n\n    def __init__(self, llm: LLMProvider) -&gt; None:\n        \"\"\"Initialize converter.\n\n        Args:\n            llm: LLM provider for conversion\n        \"\"\"\n        self.llm = llm\n        self.code_gen = CodeGenerator(llm)\n\n    def convert_prompt_to_rules(self, prompt: str) -&gt; dict[str, Any]:\n        \"\"\"Convert a prompt to generation rules.\n\n        Args:\n            prompt: User prompt describing data to generate\n\n        Returns:\n            Dictionary of rules\n        \"\"\"\n        return self.code_gen.generate_rules_from_prompt(prompt)\n\n    def convert_prompt_to_code(self, prompt: str) -&gt; str:\n        \"\"\"Convert a prompt to executable Python code.\n\n        Args:\n            prompt: User prompt describing data to generate\n\n        Returns:\n            Generated Python code\n        \"\"\"\n        return self.code_gen.generate_code_from_prompt(prompt)\n\n    def extract_resource_types(self, prompt: str) -&gt; list[str]:\n        \"\"\"Extract FHIR resource types mentioned in prompt.\n\n        Args:\n            prompt: User prompt\n\n        Returns:\n            List of resource types\n        \"\"\"\n        prompt_lower = prompt.lower()\n        found = [rt for rt in SUPPORTED_RESOURCE_TYPES if rt.lower() in prompt_lower]\n\n        # Default to Patient if none found\n        return found or [\"Patient\"]\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.PromptToRulesConverter.__init__","title":"<code>__init__(llm)</code>","text":"<p>Initialize converter.</p> <p>Parameters:</p> Name Type Description Default <code>llm</code> <code>LLMProvider</code> <p>LLM provider for conversion</p> required Source code in <code>src/fhir_synth/code_generator/converter.py</code> <pre><code>def __init__(self, llm: LLMProvider) -&gt; None:\n    \"\"\"Initialize converter.\n\n    Args:\n        llm: LLM provider for conversion\n    \"\"\"\n    self.llm = llm\n    self.code_gen = CodeGenerator(llm)\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.PromptToRulesConverter.convert_prompt_to_rules","title":"<code>convert_prompt_to_rules(prompt)</code>","text":"<p>Convert a prompt to generation rules.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>User prompt describing data to generate</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of rules</p> Source code in <code>src/fhir_synth/code_generator/converter.py</code> <pre><code>def convert_prompt_to_rules(self, prompt: str) -&gt; dict[str, Any]:\n    \"\"\"Convert a prompt to generation rules.\n\n    Args:\n        prompt: User prompt describing data to generate\n\n    Returns:\n        Dictionary of rules\n    \"\"\"\n    return self.code_gen.generate_rules_from_prompt(prompt)\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.PromptToRulesConverter.convert_prompt_to_code","title":"<code>convert_prompt_to_code(prompt)</code>","text":"<p>Convert a prompt to executable Python code.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>User prompt describing data to generate</p> required <p>Returns:</p> Type Description <code>str</code> <p>Generated Python code</p> Source code in <code>src/fhir_synth/code_generator/converter.py</code> <pre><code>def convert_prompt_to_code(self, prompt: str) -&gt; str:\n    \"\"\"Convert a prompt to executable Python code.\n\n    Args:\n        prompt: User prompt describing data to generate\n\n    Returns:\n        Generated Python code\n    \"\"\"\n    return self.code_gen.generate_code_from_prompt(prompt)\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.PromptToRulesConverter.extract_resource_types","title":"<code>extract_resource_types(prompt)</code>","text":"<p>Extract FHIR resource types mentioned in prompt.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>User prompt</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of resource types</p> Source code in <code>src/fhir_synth/code_generator/converter.py</code> <pre><code>def extract_resource_types(self, prompt: str) -&gt; list[str]:\n    \"\"\"Extract FHIR resource types mentioned in prompt.\n\n    Args:\n        prompt: User prompt\n\n    Returns:\n        List of resource types\n    \"\"\"\n    prompt_lower = prompt.lower()\n    found = [rt for rt in SUPPORTED_RESOURCE_TYPES if rt.lower() in prompt_lower]\n\n    # Default to Patient if none found\n    return found or [\"Patient\"]\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator","title":"<code>CodeGenerator</code>","text":"<p>Generates Python code for FHIR resource creation from natural language.</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>class CodeGenerator:\n    \"\"\"Generates Python code for FHIR resource creation from natural language.\"\"\"\n\n    def __init__(self, llm: LLMProvider, max_retries: int = 2) -&gt; None:\n        \"\"\"Initialize code generator with LLM.\n\n        Args:\n            llm: LLM provider for code generation\n            max_retries: Number of times to retry if generated code fails execution\n        \"\"\"\n        self.llm = llm\n        self.max_retries = max_retries\n\n    def generate_code_from_prompt(self, prompt: str) -&gt; str:\n        \"\"\"Generate Python code from natural language prompt.\n\n        Args:\n            prompt: Natural language description of resources to generate\n\n        Returns:\n            Generated Python code as string\n        \"\"\"\n        user_prompt = build_code_prompt(prompt)\n        code = self.llm.generate_text(SYSTEM_PROMPT, user_prompt)\n        return extract_code(code)\n\n    def generate_rules_from_prompt(self, prompt: str) -&gt; dict[str, Any]:\n        \"\"\"Generate rule definitions from prompt.\n\n        Args:\n            prompt: Natural language description of generation rules\n\n        Returns:\n            Dictionary of rule definitions\n        \"\"\"\n        user_prompt = build_rules_prompt(prompt)\n        result = self.llm.generate_json(SYSTEM_PROMPT, user_prompt)\n        return result\n\n    def generate_bundle_code(self, resource_types: list[str], count_per_resource: int = 10) -&gt; str:\n        \"\"\"Generate code for creating a FHIR bundle with multiple resource types.\n\n        Args:\n            resource_types: List of FHIR resource types to include (e.g., [\"Patient\", \"Condition\"])\n            count_per_resource: Number of each resource type to generate\n\n        Returns:\n            Generated Python code\n        \"\"\"\n        user_prompt = build_bundle_code_prompt(resource_types, count_per_resource)\n        code = self.llm.generate_text(SYSTEM_PROMPT, user_prompt)\n        return extract_code(code)\n\n    def validate_code(self, code: str) -&gt; bool:\n        \"\"\"Validate that generated code is safe and syntactically correct.\n\n        Args:\n            code: Python code to validate\n\n        Returns:\n            True if valid, False otherwise\n        \"\"\"\n        return validate_code(code)\n\n    def execute_generated_code(self, code: str, timeout: int = 30) -&gt; list[dict[str, Any]]:\n        \"\"\"Execute generated code safely, with self-healing retry on failure.\n\n        If execution fails, the error is sent back to the LLM to produce a\n        corrected version. This repeats up to ``max_retries`` times.\n\n        Args:\n            code: Generated Python code\n            timeout: Timeout in seconds\n\n        Returns:\n            List of generated resources\n        \"\"\"\n        last_error: Exception | None = None\n\n        for attempt in range(1 + self.max_retries):\n            if not validate_code(code):\n                last_error = ValueError(\"Generated code is not valid Python\")\n                code = self._retry_with_error(code, str(last_error))\n                continue\n\n            try:\n                return execute_code(code)\n            except Exception as exc:\n                last_error = exc\n                if attempt &lt; self.max_retries:\n                    code = self._retry_with_error(code, str(exc))\n\n        raise RuntimeError(\n            f\"Code execution failed after {self.max_retries + 1} attempts: {last_error}\"\n        ) from last_error\n\n    def _retry_with_error(self, code: str, error: str) -&gt; str:\n        \"\"\"Ask the LLM to fix broken generated code.\n\n        Args:\n            code: The code that failed\n            error: The error message / traceback\n\n        Returns:\n            Corrected Python code\n        \"\"\"\n        fix_prompt = build_fix_prompt(code, error)\n        fixed = self.llm.generate_text(SYSTEM_PROMPT, fix_prompt)\n        return extract_code(fixed)\n\n    @staticmethod\n    def apply_metadata_to_resources(\n        resources: list[dict[str, Any]],\n        security: list[dict[str, Any]] | None = None,\n        tag: list[dict[str, Any]] | None = None,\n        profile: list[str] | None = None,\n        source: str | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Apply metadata to a list of resources.\n\n        Args:\n            resources: List of FHIR resource dicts\n            security: Security labels to add\n            tag: Tags to add\n            profile: Profile URLs to add\n            source: Source system URI\n\n        Returns:\n            Modified resources with metadata\n        \"\"\"\n        for resource in resources:\n            if not any([security, tag, profile, source]):\n                continue\n\n            meta = resource.setdefault(\"meta\", {})\n\n            if security:\n                existing = meta.get(\"security\", [])\n                meta[\"security\"] = existing + security\n\n            if tag:\n                existing = meta.get(\"tag\", [])\n                meta[\"tag\"] = existing + tag\n\n            if profile:\n                existing = meta.get(\"profile\", [])\n                meta[\"profile\"] = existing + profile\n\n            if source:\n                meta[\"source\"] = source\n\n        return resources\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.__init__","title":"<code>__init__(llm, max_retries=2)</code>","text":"<p>Initialize code generator with LLM.</p> <p>Parameters:</p> Name Type Description Default <code>llm</code> <code>LLMProvider</code> <p>LLM provider for code generation</p> required <code>max_retries</code> <code>int</code> <p>Number of times to retry if generated code fails execution</p> <code>2</code> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>def __init__(self, llm: LLMProvider, max_retries: int = 2) -&gt; None:\n    \"\"\"Initialize code generator with LLM.\n\n    Args:\n        llm: LLM provider for code generation\n        max_retries: Number of times to retry if generated code fails execution\n    \"\"\"\n    self.llm = llm\n    self.max_retries = max_retries\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.generate_code_from_prompt","title":"<code>generate_code_from_prompt(prompt)</code>","text":"<p>Generate Python code from natural language prompt.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>Natural language description of resources to generate</p> required <p>Returns:</p> Type Description <code>str</code> <p>Generated Python code as string</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>def generate_code_from_prompt(self, prompt: str) -&gt; str:\n    \"\"\"Generate Python code from natural language prompt.\n\n    Args:\n        prompt: Natural language description of resources to generate\n\n    Returns:\n        Generated Python code as string\n    \"\"\"\n    user_prompt = build_code_prompt(prompt)\n    code = self.llm.generate_text(SYSTEM_PROMPT, user_prompt)\n    return extract_code(code)\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.generate_rules_from_prompt","title":"<code>generate_rules_from_prompt(prompt)</code>","text":"<p>Generate rule definitions from prompt.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>Natural language description of generation rules</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of rule definitions</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>def generate_rules_from_prompt(self, prompt: str) -&gt; dict[str, Any]:\n    \"\"\"Generate rule definitions from prompt.\n\n    Args:\n        prompt: Natural language description of generation rules\n\n    Returns:\n        Dictionary of rule definitions\n    \"\"\"\n    user_prompt = build_rules_prompt(prompt)\n    result = self.llm.generate_json(SYSTEM_PROMPT, user_prompt)\n    return result\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.generate_bundle_code","title":"<code>generate_bundle_code(resource_types, count_per_resource=10)</code>","text":"<p>Generate code for creating a FHIR bundle with multiple resource types.</p> <p>Parameters:</p> Name Type Description Default <code>resource_types</code> <code>list[str]</code> <p>List of FHIR resource types to include (e.g., [\"Patient\", \"Condition\"])</p> required <code>count_per_resource</code> <code>int</code> <p>Number of each resource type to generate</p> <code>10</code> <p>Returns:</p> Type Description <code>str</code> <p>Generated Python code</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>def generate_bundle_code(self, resource_types: list[str], count_per_resource: int = 10) -&gt; str:\n    \"\"\"Generate code for creating a FHIR bundle with multiple resource types.\n\n    Args:\n        resource_types: List of FHIR resource types to include (e.g., [\"Patient\", \"Condition\"])\n        count_per_resource: Number of each resource type to generate\n\n    Returns:\n        Generated Python code\n    \"\"\"\n    user_prompt = build_bundle_code_prompt(resource_types, count_per_resource)\n    code = self.llm.generate_text(SYSTEM_PROMPT, user_prompt)\n    return extract_code(code)\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.validate_code","title":"<code>validate_code(code)</code>","text":"<p>Validate that generated code is safe and syntactically correct.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>def validate_code(self, code: str) -&gt; bool:\n    \"\"\"Validate that generated code is safe and syntactically correct.\n\n    Args:\n        code: Python code to validate\n\n    Returns:\n        True if valid, False otherwise\n    \"\"\"\n    return validate_code(code)\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.execute_generated_code","title":"<code>execute_generated_code(code, timeout=30)</code>","text":"<p>Execute generated code safely, with self-healing retry on failure.</p> <p>If execution fails, the error is sent back to the LLM to produce a corrected version. This repeats up to <code>max_retries</code> times.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Generated Python code</p> required <code>timeout</code> <code>int</code> <p>Timeout in seconds</p> <code>30</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of generated resources</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>def execute_generated_code(self, code: str, timeout: int = 30) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute generated code safely, with self-healing retry on failure.\n\n    If execution fails, the error is sent back to the LLM to produce a\n    corrected version. This repeats up to ``max_retries`` times.\n\n    Args:\n        code: Generated Python code\n        timeout: Timeout in seconds\n\n    Returns:\n        List of generated resources\n    \"\"\"\n    last_error: Exception | None = None\n\n    for attempt in range(1 + self.max_retries):\n        if not validate_code(code):\n            last_error = ValueError(\"Generated code is not valid Python\")\n            code = self._retry_with_error(code, str(last_error))\n            continue\n\n        try:\n            return execute_code(code)\n        except Exception as exc:\n            last_error = exc\n            if attempt &lt; self.max_retries:\n                code = self._retry_with_error(code, str(exc))\n\n    raise RuntimeError(\n        f\"Code execution failed after {self.max_retries + 1} attempts: {last_error}\"\n    ) from last_error\n</code></pre>"},{"location":"api/code_generator/#fhir_synth.code_generator.CodeGenerator.apply_metadata_to_resources","title":"<code>apply_metadata_to_resources(resources, security=None, tag=None, profile=None, source=None)</code>  <code>staticmethod</code>","text":"<p>Apply metadata to a list of resources.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>list[dict[str, Any]]</code> <p>List of FHIR resource dicts</p> required <code>security</code> <code>list[dict[str, Any]] | None</code> <p>Security labels to add</p> <code>None</code> <code>tag</code> <code>list[dict[str, Any]] | None</code> <p>Tags to add</p> <code>None</code> <code>profile</code> <code>list[str] | None</code> <p>Profile URLs to add</p> <code>None</code> <code>source</code> <code>str | None</code> <p>Source system URI</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>Modified resources with metadata</p> Source code in <code>src/fhir_synth/code_generator/generator.py</code> <pre><code>@staticmethod\ndef apply_metadata_to_resources(\n    resources: list[dict[str, Any]],\n    security: list[dict[str, Any]] | None = None,\n    tag: list[dict[str, Any]] | None = None,\n    profile: list[str] | None = None,\n    source: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Apply metadata to a list of resources.\n\n    Args:\n        resources: List of FHIR resource dicts\n        security: Security labels to add\n        tag: Tags to add\n        profile: Profile URLs to add\n        source: Source system URI\n\n    Returns:\n        Modified resources with metadata\n    \"\"\"\n    for resource in resources:\n        if not any([security, tag, profile, source]):\n            continue\n\n        meta = resource.setdefault(\"meta\", {})\n\n        if security:\n            existing = meta.get(\"security\", [])\n            meta[\"security\"] = existing + security\n\n        if tag:\n            existing = meta.get(\"tag\", [])\n            meta[\"tag\"] = existing + tag\n\n        if profile:\n            existing = meta.get(\"profile\", [])\n            meta[\"profile\"] = existing + profile\n\n        if source:\n            meta[\"source\"] = source\n\n    return resources\n</code></pre>"},{"location":"api/fhir_spec/","title":"FHIR Spec","text":""},{"location":"api/fhir_spec/#fhir_synth.fhir_spec","title":"<code>fhir_synth.fhir_spec</code>","text":"<p>Auto-discover the full FHIR R4B specification from fhir.resources.</p> <p>This module uses lazy loading \u2014 it scans filesystem module names at import time (instant) but only imports the heavy Pydantic model classes on demand.</p>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec--public-api","title":"Public API","text":"<ul> <li><code>resource_names()</code> \u2013 sorted list of all resource type names</li> <li><code>get_resource_class</code> \u2013 import and return the Pydantic class for a name</li> <li><code>required_fields</code> \u2013 required field names for a resource type</li> <li><code>field_schema</code> \u2013 full field metadata for a resource type</li> <li><code>reference_targets</code> \u2013 which resource types a reference field can point to</li> <li><code>spec_summary</code> \u2013 compact text summary suitable for LLM prompts</li> </ul>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.FieldMeta","title":"<code>FieldMeta</code>  <code>dataclass</code>","text":"<p>Metadata about a single field on a FHIR resource.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>@dataclass(frozen=True)\nclass FieldMeta:\n    \"\"\"Metadata about a single field on a FHIR resource.\"\"\"\n\n    name: str\n    required: bool\n    type_annotation: str\n    is_reference: bool = False\n    is_list: bool = False\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.ResourceMeta","title":"<code>ResourceMeta</code>  <code>dataclass</code>","text":"<p>Metadata about a FHIR R4B resource type.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>@dataclass(frozen=True)\nclass ResourceMeta:\n    \"\"\"Metadata about a FHIR R4B resource type.\"\"\"\n\n    name: str\n    module: str\n    required_fields: tuple[str, ...]\n    all_fields: tuple[FieldMeta, ...] = field(default=(), repr=False)\n\n    @property\n    def optional_fields(self) -&gt; tuple[str, ...]:\n        return tuple(f.name for f in self.all_fields if not f.required)\n\n    @property\n    def reference_fields(self) -&gt; tuple[str, ...]:\n        return tuple(f.name for f in self.all_fields if f.is_reference)\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.get_resource_class","title":"<code>get_resource_class(name)</code>  <code>cached</code>","text":"<p>Import and return the Pydantic model class for a resource type.</p> <p>Results are cached so each module is only imported once.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If name is not a known resource type.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>@cache\ndef get_resource_class(name: str) -&gt; type[BaseModel]:\n    \"\"\"Import and return the Pydantic model class for a resource type.\n\n    Results are cached so each module is only imported once.\n\n    Raises:\n        ValueError: If *name* is not a known resource type.\n    \"\"\"\n    modname = _MODULE_MAP.get(name)\n    if modname is None:\n        raise ValueError(\n            f\"Unknown FHIR resource type: {name!r}. Known: {', '.join(sorted(_MODULE_MAP)[:20])} \u2026\"\n        )\n    mod = importlib.import_module(f\"fhir.resources.R4B.{modname}\")\n    cls = getattr(mod, name, None)\n    if cls is None:\n        # Try case-insensitive lookup\n        for attr in dir(mod):\n            if attr.lower() == name.lower() and hasattr(getattr(mod, attr), \"model_fields\"):\n                cls = getattr(mod, attr)\n                break\n    if cls is None:\n        raise ValueError(f\"Could not find class {name!r} in fhir.resources.R4B.{modname}\")\n    return cls  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.resource_names","title":"<code>resource_names()</code>","text":"<p>Sorted list of all known FHIR R4B resource type names.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>def resource_names() -&gt; list[str]:\n    \"\"\"Sorted list of all known FHIR R4B resource type names.\"\"\"\n    return sorted(_MODULE_MAP.keys())\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.required_fields","title":"<code>required_fields(name)</code>","text":"<p>Required field names for a resource type.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>def required_fields(name: str) -&gt; tuple[str, ...]:\n    \"\"\"Required field names for a resource type.\"\"\"\n    return _introspect(name).required_fields\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.field_schema","title":"<code>field_schema(name)</code>","text":"<p>Field metadata as plain dicts (JSON-safe).</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>def field_schema(name: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Field metadata as plain dicts (JSON-safe).\"\"\"\n    meta = _introspect(name)\n    return [\n        {\n            \"name\": f.name,\n            \"required\": f.required,\n            \"type\": f.type_annotation,\n            \"is_reference\": f.is_reference,\n            \"is_list\": f.is_list,\n        }\n        for f in meta.all_fields\n    ]\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.reference_targets","title":"<code>reference_targets(name)</code>","text":"<p>Mapping of reference field names \u2192 type annotations.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>def reference_targets(name: str) -&gt; dict[str, str]:\n    \"\"\"Mapping of reference field names \u2192 type annotations.\"\"\"\n    meta = _introspect(name)\n    return {f.name: f.type_annotation for f in meta.all_fields if f.is_reference}\n</code></pre>"},{"location":"api/fhir_spec/#fhir_synth.fhir_spec.spec_summary","title":"<code>spec_summary(resource_types=None)</code>","text":"<p>Compact text summary of the FHIR spec for the given resources.</p> <p>Designed to be injected into LLM system prompts so the model knows exactly which fields are required / optional / references.</p> Source code in <code>src/fhir_synth/fhir_spec.py</code> <pre><code>def spec_summary(resource_types: list[str] | None = None) -&gt; str:\n    \"\"\"Compact text summary of the FHIR spec for the given resources.\n\n    Designed to be injected into LLM system prompts so the model knows\n    exactly which fields are required / optional / references.\n    \"\"\"\n    types = resource_types or CLINICAL_RESOURCES\n    lines: list[str] = [f\"FHIR R4B Spec \u2014 {len(types)} resource types\\n\"]\n\n    for rt in types:\n        try:\n            meta = _introspect(rt)\n        except ValueError:\n            continue\n        req = \", \".join(meta.required_fields) or \"(none)\"\n        refs = \", \".join(meta.reference_fields) or \"(none)\"\n        opt_sample = \", \".join(meta.optional_fields[:8])\n        if len(meta.optional_fields) &gt; 8:\n            opt_sample += \" \u2026\"\n        lines.append(f\"{rt}:\")\n        lines.append(f\"  required: {req}\")\n        lines.append(f\"  references: {refs}\")\n        lines.append(f\"  optional: {opt_sample}\")\n        lines.append(\"\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/fhir_utils/","title":"FHIR Utils","text":""},{"location":"api/fhir_utils/#fhir_synth.fhir_utils","title":"<code>fhir_synth.fhir_utils</code>","text":"<p>FHIR resource utilities for working with fhir.resources library.</p>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory","title":"<code>BundleFactory</code>","text":"<p>Factory for building FHIR Bundles with Pydantic model resources.</p> <p>This class bridges Pydantic models with the bundle builder, automatically converting models to dicts.</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>class BundleFactory:\n    \"\"\"Factory for building FHIR Bundles with Pydantic model resources.\n\n    This class bridges Pydantic models with the bundle builder,\n    automatically converting models to dicts.\n    \"\"\"\n\n    def __init__(self, bundle_type: str = \"transaction\") -&gt; None:\n        \"\"\"Initialize bundle factory.\n\n        Args:\n            bundle_type: Type of bundle to create\n        \"\"\"\n        self.bundle_type = bundle_type\n        self.entries: list[dict[str, Any]] = []\n\n    def add_resource(\n        self,\n        resource: BaseModel | dict[str, Any],\n        method: str = \"POST\",\n    ) -&gt; None:\n        \"\"\"Add a resource to the bundle.\n\n        Args:\n            resource: FHIR resource (Pydantic model or dict)\n            method: HTTP method (POST, PUT, DELETE, GET)\n        \"\"\"\n        # Convert Pydantic model to dict if needed\n        if isinstance(resource, BaseModel):\n            resource_dict = resource.model_dump(exclude_none=True, by_alias=True)\n        else:\n            resource_dict = resource\n\n        resource_type = resource_dict.get(\"resourceType\")\n        resource_id = resource_dict.get(\"id\")\n\n        url = f\"{resource_type}\" + (f\"/{resource_id}\" if resource_id else \"\")\n\n        entry = {\n            \"fullUrl\": f\"urn:uuid:{resource_id}\",\n            \"resource\": resource_dict,\n            \"request\": {\n                \"method\": method,\n                \"url\": url,\n            },\n        }\n        self.entries.append(entry)\n\n    def add_resources(\n        self,\n        resources: list[BaseModel | dict[str, Any]],\n        method: str = \"POST\",\n    ) -&gt; None:\n        \"\"\"Add multiple resources to the bundle.\n\n        Args:\n            resources: List of FHIR resources\n            method: HTTP method for all resources\n        \"\"\"\n        for resource in resources:\n            self.add_resource(resource, method)\n\n    def build(self) -&gt; dict[str, Any]:\n        \"\"\"Build the FHIR Bundle as a dictionary.\n\n        Returns:\n            Complete FHIR Bundle resource as dict\n        \"\"\"\n        import uuid\n        from datetime import UTC, datetime\n\n        return {\n            \"resourceType\": \"Bundle\",\n            \"id\": str(uuid.uuid4()),\n            \"type\": self.bundle_type,\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            \"total\": len(self.entries),\n            \"entry\": self.entries,\n        }\n\n    def build_pydantic(self) -&gt; BaseModel:\n        \"\"\"Build the bundle and return as Pydantic model.\n\n        Returns:\n            Bundle as a Pydantic model\n        \"\"\"\n        from fhir_synth.fhir_spec import get_resource_class\n\n        bundle_dict = self.build()\n        bundle_class = get_resource_class(\"Bundle\")\n        return bundle_class(**bundle_dict)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all entries.\"\"\"\n        self.entries = []\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory.__init__","title":"<code>__init__(bundle_type='transaction')</code>","text":"<p>Initialize bundle factory.</p> <p>Parameters:</p> Name Type Description Default <code>bundle_type</code> <code>str</code> <p>Type of bundle to create</p> <code>'transaction'</code> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def __init__(self, bundle_type: str = \"transaction\") -&gt; None:\n    \"\"\"Initialize bundle factory.\n\n    Args:\n        bundle_type: Type of bundle to create\n    \"\"\"\n    self.bundle_type = bundle_type\n    self.entries: list[dict[str, Any]] = []\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory.add_resource","title":"<code>add_resource(resource, method='POST')</code>","text":"<p>Add a resource to the bundle.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>BaseModel | dict[str, Any]</code> <p>FHIR resource (Pydantic model or dict)</p> required <code>method</code> <code>str</code> <p>HTTP method (POST, PUT, DELETE, GET)</p> <code>'POST'</code> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def add_resource(\n    self,\n    resource: BaseModel | dict[str, Any],\n    method: str = \"POST\",\n) -&gt; None:\n    \"\"\"Add a resource to the bundle.\n\n    Args:\n        resource: FHIR resource (Pydantic model or dict)\n        method: HTTP method (POST, PUT, DELETE, GET)\n    \"\"\"\n    # Convert Pydantic model to dict if needed\n    if isinstance(resource, BaseModel):\n        resource_dict = resource.model_dump(exclude_none=True, by_alias=True)\n    else:\n        resource_dict = resource\n\n    resource_type = resource_dict.get(\"resourceType\")\n    resource_id = resource_dict.get(\"id\")\n\n    url = f\"{resource_type}\" + (f\"/{resource_id}\" if resource_id else \"\")\n\n    entry = {\n        \"fullUrl\": f\"urn:uuid:{resource_id}\",\n        \"resource\": resource_dict,\n        \"request\": {\n            \"method\": method,\n            \"url\": url,\n        },\n    }\n    self.entries.append(entry)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory.add_resources","title":"<code>add_resources(resources, method='POST')</code>","text":"<p>Add multiple resources to the bundle.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>list[BaseModel | dict[str, Any]]</code> <p>List of FHIR resources</p> required <code>method</code> <code>str</code> <p>HTTP method for all resources</p> <code>'POST'</code> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def add_resources(\n    self,\n    resources: list[BaseModel | dict[str, Any]],\n    method: str = \"POST\",\n) -&gt; None:\n    \"\"\"Add multiple resources to the bundle.\n\n    Args:\n        resources: List of FHIR resources\n        method: HTTP method for all resources\n    \"\"\"\n    for resource in resources:\n        self.add_resource(resource, method)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory.build","title":"<code>build()</code>","text":"<p>Build the FHIR Bundle as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Complete FHIR Bundle resource as dict</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def build(self) -&gt; dict[str, Any]:\n    \"\"\"Build the FHIR Bundle as a dictionary.\n\n    Returns:\n        Complete FHIR Bundle resource as dict\n    \"\"\"\n    import uuid\n    from datetime import UTC, datetime\n\n    return {\n        \"resourceType\": \"Bundle\",\n        \"id\": str(uuid.uuid4()),\n        \"type\": self.bundle_type,\n        \"timestamp\": datetime.now(UTC).isoformat(),\n        \"total\": len(self.entries),\n        \"entry\": self.entries,\n    }\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory.build_pydantic","title":"<code>build_pydantic()</code>","text":"<p>Build the bundle and return as Pydantic model.</p> <p>Returns:</p> Type Description <code>BaseModel</code> <p>Bundle as a Pydantic model</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def build_pydantic(self) -&gt; BaseModel:\n    \"\"\"Build the bundle and return as Pydantic model.\n\n    Returns:\n        Bundle as a Pydantic model\n    \"\"\"\n    from fhir_synth.fhir_spec import get_resource_class\n\n    bundle_dict = self.build()\n    bundle_class = get_resource_class(\"Bundle\")\n    return bundle_class(**bundle_dict)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.BundleFactory.clear","title":"<code>clear()</code>","text":"<p>Clear all entries.</p> Source code in <code>src/fhir_synth/bundle/factory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all entries.\"\"\"\n    self.entries = []\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory","title":"<code>FHIRResourceFactory</code>","text":"<p>Factory for creating FHIR resources from dictionaries.</p> <p>All factory methods use <code>get_resource_class</code> so they support every FHIR R4B resource type without hardcoding imports.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>class FHIRResourceFactory:\n    \"\"\"Factory for creating FHIR resources from dictionaries.\n\n    All factory methods use ``get_resource_class`` so they support every\n    FHIR R4B resource type without hardcoding imports.\n    \"\"\"\n\n    @staticmethod\n    def create_resource(resource_type: str, data: dict[str, Any]) -&gt; BaseModel:\n        \"\"\"Create any FHIR resource from a type name and data dict.\n\n        This is the **generic** factory method \u2014 it can create any of the\n        141 R4B resource types.\n\n        Args:\n            resource_type: FHIR resource type name (e.g. \"Patient\", \"Claim\")\n            data: Resource data dictionary\n\n        Returns:\n            FHIR resource Pydantic model instance\n        \"\"\"\n        cls: type[BaseModel] = get_resource_class(resource_type)\n        data.setdefault(\"resourceType\", resource_type)\n        return cls(**data)\n\n    @staticmethod\n    def create_patient(\n        id: str,\n        given_name: str = \"John\",\n        family_name: str = \"Doe\",\n        birth_date: str | None = None,\n        **kwargs: Any,\n    ) -&gt; BaseModel:\n        \"\"\"Create a FHIR Patient resource.\"\"\"\n        data: dict[str, Any] = {\n            \"id\": id,\n            \"resourceType\": \"Patient\",\n            \"name\": [{\"given\": [given_name], \"family\": family_name}],\n            **kwargs,\n        }\n        if birth_date:\n            data[\"birthDate\"] = birth_date\n        cls: type[BaseModel] = get_resource_class(\"Patient\")\n        return cls(**data)\n\n    @staticmethod\n    def create_condition(\n        id: str,\n        code: str,\n        patient_id: str,\n        system: str = \"http://hl7.org/fhir/sid/icd-10-cm\",\n        **kwargs: Any,\n    ) -&gt; BaseModel:\n        \"\"\"Create a FHIR Condition resource.\"\"\"\n        data: dict[str, Any] = {\n            \"id\": id,\n            \"resourceType\": \"Condition\",\n            \"code\": {\"coding\": [{\"code\": code, \"system\": system}]},\n            \"subject\": {\"reference\": f\"Patient/{patient_id}\"},\n            **kwargs,\n        }\n        cls: type[BaseModel] = get_resource_class(\"Condition\")\n        return cls(**data)\n\n    @staticmethod\n    def create_observation(\n        id: str,\n        code: str,\n        patient_id: str,\n        value: str | int | float | None = None,\n        loinc_code: str = \"4548-4\",\n        **kwargs: Any,\n    ) -&gt; BaseModel:\n        \"\"\"Create a FHIR Observation resource.\"\"\"\n        data: dict[str, Any] = {\n            \"id\": id,\n            \"resourceType\": \"Observation\",\n            \"status\": \"final\",\n            \"code\": {\"coding\": [{\"code\": loinc_code, \"system\": \"http://loinc.org\"}]},\n            \"subject\": {\"reference\": f\"Patient/{patient_id}\"},\n            **kwargs,\n        }\n        if value is not None:\n            data[\"valueQuantity\"] = {\"value\": value}\n        cls: type[BaseModel] = get_resource_class(\"Observation\")\n        return cls(**data)\n\n    @staticmethod\n    def create_medication_request(\n        id: str,\n        medication_code: str,\n        patient_id: str,\n        status: str = \"active\",\n        **kwargs: Any,\n    ) -&gt; BaseModel:\n        \"\"\"Create a FHIR MedicationRequest resource.\"\"\"\n        data: dict[str, Any] = {\n            \"id\": id,\n            \"resourceType\": \"MedicationRequest\",\n            \"status\": status,\n            \"intent\": \"order\",\n            \"medicationCodeableConcept\": {\n                \"coding\": [\n                    {\n                        \"code\": medication_code,\n                        \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                    }\n                ]\n            },\n            \"subject\": {\"reference\": f\"Patient/{patient_id}\"},\n            **kwargs,\n        }\n        cls: type[BaseModel] = get_resource_class(\"MedicationRequest\")\n        return cls(**data)\n\n    @staticmethod\n    def create_bundle(\n        bundle_type: str = \"transaction\",\n        entries: list[dict[str, Any]] | None = None,\n        **kwargs: Any,\n    ) -&gt; BaseModel:\n        \"\"\"Create a FHIR Bundle resource.\"\"\"\n        import uuid\n        from datetime import UTC, datetime\n\n        data: dict[str, Any] = {\n            \"id\": str(uuid.uuid4()),\n            \"resourceType\": \"Bundle\",\n            \"type\": bundle_type,\n            \"timestamp\": datetime.now(UTC).isoformat(),\n            **kwargs,\n        }\n        if entries:\n            data[\"entry\"] = entries\n        cls: type[BaseModel] = get_resource_class(\"Bundle\")\n        return cls(**data)\n\n    @staticmethod\n    def from_dict(resource_type: str, data: dict[str, Any]) -&gt; BaseModel:\n        \"\"\"Create any FHIR resource from a type name and data dict.\n\n        Supports all 141 R4B resource types via auto-discovery.\n        \"\"\"\n        cls: type[BaseModel] = get_resource_class(resource_type)\n        return cls(**data)\n\n    @staticmethod\n    def to_dict(resource: BaseModel) -&gt; dict[str, Any]:\n        \"\"\"Convert a FHIR resource to a dictionary.\n\n        Args:\n            resource: FHIR resource instance\n\n        Returns:\n            Dictionary representation\n        \"\"\"\n        return resource.model_dump(exclude_none=True, by_alias=True)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.create_resource","title":"<code>create_resource(resource_type, data)</code>  <code>staticmethod</code>","text":"<p>Create any FHIR resource from a type name and data dict.</p> <p>This is the generic factory method \u2014 it can create any of the 141 R4B resource types.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>FHIR resource type name (e.g. \"Patient\", \"Claim\")</p> required <code>data</code> <code>dict[str, Any]</code> <p>Resource data dictionary</p> required <p>Returns:</p> Type Description <code>BaseModel</code> <p>FHIR resource Pydantic model instance</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef create_resource(resource_type: str, data: dict[str, Any]) -&gt; BaseModel:\n    \"\"\"Create any FHIR resource from a type name and data dict.\n\n    This is the **generic** factory method \u2014 it can create any of the\n    141 R4B resource types.\n\n    Args:\n        resource_type: FHIR resource type name (e.g. \"Patient\", \"Claim\")\n        data: Resource data dictionary\n\n    Returns:\n        FHIR resource Pydantic model instance\n    \"\"\"\n    cls: type[BaseModel] = get_resource_class(resource_type)\n    data.setdefault(\"resourceType\", resource_type)\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.create_patient","title":"<code>create_patient(id, given_name='John', family_name='Doe', birth_date=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a FHIR Patient resource.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef create_patient(\n    id: str,\n    given_name: str = \"John\",\n    family_name: str = \"Doe\",\n    birth_date: str | None = None,\n    **kwargs: Any,\n) -&gt; BaseModel:\n    \"\"\"Create a FHIR Patient resource.\"\"\"\n    data: dict[str, Any] = {\n        \"id\": id,\n        \"resourceType\": \"Patient\",\n        \"name\": [{\"given\": [given_name], \"family\": family_name}],\n        **kwargs,\n    }\n    if birth_date:\n        data[\"birthDate\"] = birth_date\n    cls: type[BaseModel] = get_resource_class(\"Patient\")\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.create_condition","title":"<code>create_condition(id, code, patient_id, system='http://hl7.org/fhir/sid/icd-10-cm', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a FHIR Condition resource.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef create_condition(\n    id: str,\n    code: str,\n    patient_id: str,\n    system: str = \"http://hl7.org/fhir/sid/icd-10-cm\",\n    **kwargs: Any,\n) -&gt; BaseModel:\n    \"\"\"Create a FHIR Condition resource.\"\"\"\n    data: dict[str, Any] = {\n        \"id\": id,\n        \"resourceType\": \"Condition\",\n        \"code\": {\"coding\": [{\"code\": code, \"system\": system}]},\n        \"subject\": {\"reference\": f\"Patient/{patient_id}\"},\n        **kwargs,\n    }\n    cls: type[BaseModel] = get_resource_class(\"Condition\")\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.create_observation","title":"<code>create_observation(id, code, patient_id, value=None, loinc_code='4548-4', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a FHIR Observation resource.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef create_observation(\n    id: str,\n    code: str,\n    patient_id: str,\n    value: str | int | float | None = None,\n    loinc_code: str = \"4548-4\",\n    **kwargs: Any,\n) -&gt; BaseModel:\n    \"\"\"Create a FHIR Observation resource.\"\"\"\n    data: dict[str, Any] = {\n        \"id\": id,\n        \"resourceType\": \"Observation\",\n        \"status\": \"final\",\n        \"code\": {\"coding\": [{\"code\": loinc_code, \"system\": \"http://loinc.org\"}]},\n        \"subject\": {\"reference\": f\"Patient/{patient_id}\"},\n        **kwargs,\n    }\n    if value is not None:\n        data[\"valueQuantity\"] = {\"value\": value}\n    cls: type[BaseModel] = get_resource_class(\"Observation\")\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.create_medication_request","title":"<code>create_medication_request(id, medication_code, patient_id, status='active', **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a FHIR MedicationRequest resource.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef create_medication_request(\n    id: str,\n    medication_code: str,\n    patient_id: str,\n    status: str = \"active\",\n    **kwargs: Any,\n) -&gt; BaseModel:\n    \"\"\"Create a FHIR MedicationRequest resource.\"\"\"\n    data: dict[str, Any] = {\n        \"id\": id,\n        \"resourceType\": \"MedicationRequest\",\n        \"status\": status,\n        \"intent\": \"order\",\n        \"medicationCodeableConcept\": {\n            \"coding\": [\n                {\n                    \"code\": medication_code,\n                    \"system\": \"http://www.nlm.nih.gov/research/umls/rxnorm\",\n                }\n            ]\n        },\n        \"subject\": {\"reference\": f\"Patient/{patient_id}\"},\n        **kwargs,\n    }\n    cls: type[BaseModel] = get_resource_class(\"MedicationRequest\")\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.create_bundle","title":"<code>create_bundle(bundle_type='transaction', entries=None, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a FHIR Bundle resource.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef create_bundle(\n    bundle_type: str = \"transaction\",\n    entries: list[dict[str, Any]] | None = None,\n    **kwargs: Any,\n) -&gt; BaseModel:\n    \"\"\"Create a FHIR Bundle resource.\"\"\"\n    import uuid\n    from datetime import UTC, datetime\n\n    data: dict[str, Any] = {\n        \"id\": str(uuid.uuid4()),\n        \"resourceType\": \"Bundle\",\n        \"type\": bundle_type,\n        \"timestamp\": datetime.now(UTC).isoformat(),\n        **kwargs,\n    }\n    if entries:\n        data[\"entry\"] = entries\n    cls: type[BaseModel] = get_resource_class(\"Bundle\")\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.from_dict","title":"<code>from_dict(resource_type, data)</code>  <code>staticmethod</code>","text":"<p>Create any FHIR resource from a type name and data dict.</p> <p>Supports all 141 R4B resource types via auto-discovery.</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef from_dict(resource_type: str, data: dict[str, Any]) -&gt; BaseModel:\n    \"\"\"Create any FHIR resource from a type name and data dict.\n\n    Supports all 141 R4B resource types via auto-discovery.\n    \"\"\"\n    cls: type[BaseModel] = get_resource_class(resource_type)\n    return cls(**data)\n</code></pre>"},{"location":"api/fhir_utils/#fhir_synth.fhir_utils.FHIRResourceFactory.to_dict","title":"<code>to_dict(resource)</code>  <code>staticmethod</code>","text":"<p>Convert a FHIR resource to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>resource</code> <code>BaseModel</code> <p>FHIR resource instance</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation</p> Source code in <code>src/fhir_synth/fhir_utils/factory.py</code> <pre><code>@staticmethod\ndef to_dict(resource: BaseModel) -&gt; dict[str, Any]:\n    \"\"\"Convert a FHIR resource to a dictionary.\n\n    Args:\n        resource: FHIR resource instance\n\n    Returns:\n        Dictionary representation\n    \"\"\"\n    return resource.model_dump(exclude_none=True, by_alias=True)\n</code></pre>"},{"location":"api/llm/","title":"LLM","text":""},{"location":"api/llm/#fhir_synth.llm","title":"<code>fhir_synth.llm</code>","text":"<p>LLM provider interface and prompt-to-plan conversion using LiteLLM.</p>"},{"location":"api/llm/#fhir_synth.llm.LLMProvider","title":"<code>LLMProvider</code>","text":"<p>LLM provider using LiteLLM for unified access to 100+ LLM providers.</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>class LLMProvider:\n    \"\"\"LLM provider using LiteLLM for unified access to 100+ LLM providers.\"\"\"\n\n    def __init__(\n        self,\n        model: str = \"gpt-4\",\n        api_key: str | None = None,\n        api_base: str | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize LLM provider with LiteLLM.\n\n        Args:\n            model: Model name (e.g., \"gpt-4\", \"claude-3-opus\", \"bedrock/anthropic.claude-v2\")\n            api_key: API key for the provider (optional, will use env vars)\n            api_base: Custom API base URL (optional)\n            **kwargs: Additional arguments passed to litellm.completion()\n        \"\"\"\n        self.model = model\n        self.api_key = api_key\n        self.api_base = api_base\n        self.extra_kwargs = kwargs\n\n    def generate_text(\n        self, prompt: str, system: str | None = None, json_schema: dict[str, Any] | None = None\n    ) -&gt; str:\n        \"\"\"Generate text from prompt using LiteLLM.\"\"\"\n        import litellm\n\n        messages = []\n        if system:\n            messages.append({\"role\": \"system\", \"content\": system})\n        messages.append({\"role\": \"user\", \"content\": prompt})\n\n        kwargs: dict[str, Any] = {\n            \"model\": self.model,\n            \"messages\": messages,\n            **self.extra_kwargs,\n        }\n\n        if self.api_key:\n            kwargs[\"api_key\"] = self.api_key\n        if self.api_base:\n            kwargs[\"api_base\"] = self.api_base\n\n        # Request JSON mode if schema provided and model supports it\n        if json_schema:\n            kwargs[\"response_format\"] = {\"type\": \"json_object\"}\n\n        response = litellm.completion(**kwargs)\n        return response.choices[0].message.content or \"\"\n\n    def generate_json(\n        self, prompt: str, system: str | None = None, schema: dict[str, Any] | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Generate JSON from prompt.\"\"\"\n        text = self.generate_text(prompt, system, schema)\n\n        # Try to extract JSON from Markdown code blocks if present\n        if \"```json\" in text:\n            start = text.find(\"```json\") + 7\n            end = text.find(\"```\", start)\n            text = text[start:end].strip()\n        elif \"```\" in text:\n            start = text.find(\"```\") + 3\n            end = text.find(\"```\", start)\n            text = text[start:end].strip()\n\n        return json.loads(text)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.LLMProvider.__init__","title":"<code>__init__(model='gpt-4', api_key=None, api_base=None, **kwargs)</code>","text":"<p>Initialize LLM provider with LiteLLM.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>Model name (e.g., \"gpt-4\", \"claude-3-opus\", \"bedrock/anthropic.claude-v2\")</p> <code>'gpt-4'</code> <code>api_key</code> <code>str | None</code> <p>API key for the provider (optional, will use env vars)</p> <code>None</code> <code>api_base</code> <code>str | None</code> <p>Custom API base URL (optional)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to litellm.completion()</p> <code>{}</code> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>def __init__(\n    self,\n    model: str = \"gpt-4\",\n    api_key: str | None = None,\n    api_base: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize LLM provider with LiteLLM.\n\n    Args:\n        model: Model name (e.g., \"gpt-4\", \"claude-3-opus\", \"bedrock/anthropic.claude-v2\")\n        api_key: API key for the provider (optional, will use env vars)\n        api_base: Custom API base URL (optional)\n        **kwargs: Additional arguments passed to litellm.completion()\n    \"\"\"\n    self.model = model\n    self.api_key = api_key\n    self.api_base = api_base\n    self.extra_kwargs = kwargs\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.LLMProvider.generate_text","title":"<code>generate_text(prompt, system=None, json_schema=None)</code>","text":"<p>Generate text from prompt using LiteLLM.</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>def generate_text(\n    self, prompt: str, system: str | None = None, json_schema: dict[str, Any] | None = None\n) -&gt; str:\n    \"\"\"Generate text from prompt using LiteLLM.\"\"\"\n    import litellm\n\n    messages = []\n    if system:\n        messages.append({\"role\": \"system\", \"content\": system})\n    messages.append({\"role\": \"user\", \"content\": prompt})\n\n    kwargs: dict[str, Any] = {\n        \"model\": self.model,\n        \"messages\": messages,\n        **self.extra_kwargs,\n    }\n\n    if self.api_key:\n        kwargs[\"api_key\"] = self.api_key\n    if self.api_base:\n        kwargs[\"api_base\"] = self.api_base\n\n    # Request JSON mode if schema provided and model supports it\n    if json_schema:\n        kwargs[\"response_format\"] = {\"type\": \"json_object\"}\n\n    response = litellm.completion(**kwargs)\n    return response.choices[0].message.content or \"\"\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.LLMProvider.generate_json","title":"<code>generate_json(prompt, system=None, schema=None)</code>","text":"<p>Generate JSON from prompt.</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>def generate_json(\n    self, prompt: str, system: str | None = None, schema: dict[str, Any] | None = None\n) -&gt; dict[str, Any]:\n    \"\"\"Generate JSON from prompt.\"\"\"\n    text = self.generate_text(prompt, system, schema)\n\n    # Try to extract JSON from Markdown code blocks if present\n    if \"```json\" in text:\n        start = text.find(\"```json\") + 7\n        end = text.find(\"```\", start)\n        text = text[start:end].strip()\n    elif \"```\" in text:\n        start = text.find(\"```\") + 3\n        end = text.find(\"```\", start)\n        text = text[start:end].strip()\n\n    return json.loads(text)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.MockLLMProvider","title":"<code>MockLLMProvider</code>","text":"<p>               Bases: <code>LLMProvider</code></p> <p>Mock LLM provider for testing (no LiteLLM dependency).</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>class MockLLMProvider(LLMProvider):\n    \"\"\"Mock LLM provider for testing (no LiteLLM dependency).\"\"\"\n\n    def __init__(self, response: str | dict[str, Any] | None = None) -&gt; None:\n        \"\"\"Initialize with an optional fixed response.\"\"\"\n        super().__init__(model=\"mock\")\n        self.response = response\n        self.calls: list[dict[str, Any]] = []\n\n    def generate_text(\n        self, prompt: str, system: str | None = None, json_schema: dict[str, Any] | None = None\n    ) -&gt; str:\n        \"\"\"Generate mock text response.\"\"\"\n        self.calls.append({\"prompt\": prompt, \"system\": system, \"schema\": json_schema})\n\n        if isinstance(self.response, str):\n            return self.response\n        elif isinstance(self.response, dict):\n            return json.dumps(self.response)\n        else:\n            # Default mock: return Python code that generates sample resources.\n            # This allows `fhir-synth generate --provider mock` to work end-to-end.\n            return \"\"\"\nfrom fhir.resources.R4B import patient as patient_mod\n\ndef generate_resources():\n    resources = []\n    for i in range(1, 6):\n        p = patient_mod.Patient(\n            id=f\"mock-patient-{i}\",\n            name=[{\"given\": [f\"Mock{i}\"], \"family\": \"Patient\"}],\n            gender=\"unknown\",\n            birthDate=f\"199{i}-01-01\",\n        )\n        resources.append(p.model_dump())\n    return resources\n\"\"\"\n\n    def generate_json(\n        self, prompt: str, system: str | None = None, schema: dict[str, Any] | None = None\n    ) -&gt; dict[str, Any]:\n        \"\"\"Generate a mock JSON response.\"\"\"\n        text = self.generate_text(prompt, system, schema)\n        return json.loads(text)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.MockLLMProvider.__init__","title":"<code>__init__(response=None)</code>","text":"<p>Initialize with an optional fixed response.</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>def __init__(self, response: str | dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Initialize with an optional fixed response.\"\"\"\n    super().__init__(model=\"mock\")\n    self.response = response\n    self.calls: list[dict[str, Any]] = []\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.MockLLMProvider.generate_text","title":"<code>generate_text(prompt, system=None, json_schema=None)</code>","text":"<p>Generate mock text response.</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>    def generate_text(\n        self, prompt: str, system: str | None = None, json_schema: dict[str, Any] | None = None\n    ) -&gt; str:\n        \"\"\"Generate mock text response.\"\"\"\n        self.calls.append({\"prompt\": prompt, \"system\": system, \"schema\": json_schema})\n\n        if isinstance(self.response, str):\n            return self.response\n        elif isinstance(self.response, dict):\n            return json.dumps(self.response)\n        else:\n            # Default mock: return Python code that generates sample resources.\n            # This allows `fhir-synth generate --provider mock` to work end-to-end.\n            return \"\"\"\nfrom fhir.resources.R4B import patient as patient_mod\n\ndef generate_resources():\n    resources = []\n    for i in range(1, 6):\n        p = patient_mod.Patient(\n            id=f\"mock-patient-{i}\",\n            name=[{\"given\": [f\"Mock{i}\"], \"family\": \"Patient\"}],\n            gender=\"unknown\",\n            birthDate=f\"199{i}-01-01\",\n        )\n        resources.append(p.model_dump())\n    return resources\n\"\"\"\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.MockLLMProvider.generate_json","title":"<code>generate_json(prompt, system=None, schema=None)</code>","text":"<p>Generate a mock JSON response.</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>def generate_json(\n    self, prompt: str, system: str | None = None, schema: dict[str, Any] | None = None\n) -&gt; dict[str, Any]:\n    \"\"\"Generate a mock JSON response.\"\"\"\n    text = self.generate_text(prompt, system, schema)\n    return json.loads(text)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/llm/#fhir_synth.llm.get_provider","title":"<code>get_provider(provider_name='gpt-4', api_key=None, **kwargs)</code>","text":"<p>Get LLM provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider_name</code> <code>str</code> <p>Provider/model name. Use \"mock\" for testing, or any LiteLLM-supported model: - OpenAI: \"gpt-4\", \"gpt-3.5-turbo\" - Anthropic: \"claude-3-opus-20240229\", \"claude-3-sonnet-20240229\" - Bedrock: \"bedrock/anthropic.claude-v2\", \"bedrock/anthropic.claude-instant-v1\" - Azure: \"azure/gpt-4\" - And 100+ more providers</p> <code>'gpt-4'</code> <code>api_key</code> <code>str | None</code> <p>API key (optional, will use environment variables from .env or system)</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>LLMProvider</code> <p>LLMProvider instance</p> Source code in <code>src/fhir_synth/llm.py</code> <pre><code>def get_provider(\n    provider_name: str = \"gpt-4\", api_key: str | None = None, **kwargs: Any\n) -&gt; LLMProvider:\n    \"\"\"Get LLM provider.\n\n    Args:\n        provider_name: Provider/model name. Use \"mock\" for testing, or any LiteLLM-supported model:\n            - OpenAI: \"gpt-4\", \"gpt-3.5-turbo\"\n            - Anthropic: \"claude-3-opus-20240229\", \"claude-3-sonnet-20240229\"\n            - Bedrock: \"bedrock/anthropic.claude-v2\", \"bedrock/anthropic.claude-instant-v1\"\n            - Azure: \"azure/gpt-4\"\n            - And 100+ more providers\n        api_key: API key (optional, will use environment variables from .env or system)\n        **kwargs: Additional arguments\n\n    Returns:\n        LLMProvider instance\n    \"\"\"\n    if provider_name == \"mock\":\n        return MockLLMProvider(**kwargs)\n\n    # If no api_key provided, check environment for common API key names\n    if not api_key:\n        # Map provider names to environment variable names\n        env_key_map = {\n            \"gpt-4\": \"OPENAI_API_KEY\",\n            \"gpt-3.5-turbo\": \"OPENAI_API_KEY\",\n            \"claude\": \"ANTHROPIC_API_KEY\",\n            \"claude-3-opus\": \"ANTHROPIC_API_KEY\",\n            \"claude-3-sonnet\": \"ANTHROPIC_API_KEY\",\n        }\n\n        # Check for matching environment variable\n        for provider_prefix, env_var in env_key_map.items():\n            if provider_name.startswith(provider_prefix):\n                api_key = os.getenv(env_var)\n                if api_key:\n                    break\n\n    return LLMProvider(model=provider_name, api_key=api_key, **kwargs)\n</code></pre>"},{"location":"api/rule_engine/","title":"Rule Engine","text":""},{"location":"api/rule_engine/#fhir_synth.rule_engine","title":"<code>fhir_synth.rule_engine</code>","text":"<p>Rule engine for declarative FHIR resource generation.</p>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleEngine","title":"<code>RuleEngine</code>","text":"<p>Executes rules to generate FHIR resources.</p> Source code in <code>src/fhir_synth/rule_engine/engine.py</code> <pre><code>class RuleEngine:\n    \"\"\"Executes rules to generate FHIR resources.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the rule engine.\"\"\"\n        self.rulesets: dict[str, RuleSet] = {}\n        self.executors: dict[str, Callable[[Rule, dict[str, Any]], Any]] = {}\n\n    def register_ruleset(self, ruleset: RuleSet) -&gt; None:\n        \"\"\"Register a ruleset for a resource type.\"\"\"\n        self.rulesets[ruleset.resource_type] = ruleset\n\n    def register_executor(\n        self, resource_type: str, executor: Callable[[Rule, dict[str, Any]], Any]\n    ) -&gt; None:\n        \"\"\"Register a custom executor function for a resource type.\"\"\"\n        self.executors[resource_type] = executor\n\n    def execute(\n        self,\n        resource_type: str,\n        context: dict[str, Any],\n        count: int = 1,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Execute rules to generate resources.\n\n        Args:\n            resource_type: FHIR resource type to generate\n            context: Context data for rule evaluation\n            count: Number of resources to generate\n\n        Returns:\n            List of generated resources\n        \"\"\"\n        if resource_type not in self.rulesets:\n            raise ValueError(f\"No ruleset registered for {resource_type}\")\n\n        ruleset = self.rulesets[resource_type]\n        executor = self.executors.get(resource_type)\n        results = []\n\n        for _ in range(count):\n            # Select rule based on conditions and weights\n            rule = self._select_rule(ruleset, context)\n\n            # Execute the rule\n            if executor:\n                resource = executor(rule, context)\n            else:\n                resource = self._default_executor(rule, context, resource_type)\n\n            # Apply metadata from ruleset and rule\n            self._apply_metadata(resource, ruleset, rule)\n\n            results.append(resource)\n\n        return results\n\n    def _select_rule(self, ruleset: RuleSet, context: dict[str, Any]) -&gt; Rule:\n        \"\"\"Select the appropriate rule based on conditions.\"\"\"\n\n        # Filter rules that match conditions\n        matching_rules = []\n        for rule in ruleset.rules:\n            if self._check_conditions(rule.conditions, context):\n                matching_rules.append(rule)\n\n        if not matching_rules:\n            if ruleset.default_rule:\n                return ruleset.default_rule\n            elif ruleset.rules:\n                return ruleset.rules[0]\n            else:\n                raise ValueError(f\"No rules available for {ruleset.resource_type}\")\n\n        # Weighted random selection\n        weights = [rule.weight for rule in matching_rules]\n        return random.choices(matching_rules, weights=weights, k=1)[0]\n\n    @staticmethod\n    def _check_conditions(conditions: dict[str, Any], context: dict[str, Any]) -&gt; bool:\n        \"\"\"Check if all conditions are met.\"\"\"\n        for key, expected_value in conditions.items():\n            if context.get(key) != expected_value:\n                return False\n        return True\n\n    @staticmethod\n    def _default_executor(\n        rule: Rule, context: dict[str, Any], resource_type: str\n    ) -&gt; dict[str, Any]:\n        \"\"\"Default executor \u2014 builds a resource dict from rule actions.\n\n        Always sets ``resourceType`` from the ruleset so the output is a\n        valid FHIR resource skeleton regardless of what the rule specifies.\n        \"\"\"\n        resource: dict[str, Any] = {\n            \"resourceType\": resource_type,\n            \"id\": context.get(\"id\", str(uuid.uuid4())),\n        }\n        resource.update(rule.actions)\n        return resource\n\n    def generate_bundle(\n        self,\n        resource_type: str,\n        resources: list[dict[str, Any]],\n        bundle_type: str = \"transaction\",\n    ) -&gt; dict[str, Any]:\n        \"\"\"Create a FHIR Bundle from resources.\n\n        Args:\n            resource_type: Expected resourceType for all bundled resources\n            resources: List of resources to bundle\n            bundle_type: Bundle type (transaction, batch, searchset, etc.)\n\n        Returns:\n            FHIR Bundle resource\n        \"\"\"\n        for resource in resources:\n            if resource.get(\"resourceType\") != resource_type:\n                raise ValueError(\n                    \"All resources must match resource_type; \"\n                    f\"expected '{resource_type}', got '{resource.get('resourceType')}'\"\n                )\n        bundle_id = self._generate_id()\n        bundle_entries = []\n\n        for resource in resources:\n            entry = {\n                \"fullUrl\": f\"urn:uuid:{self._generate_id()}\",\n                \"resource\": resource,\n                \"request\": {\n                    \"method\": \"POST\",\n                    \"url\": resource.get(\"resourceType\", \"\"),\n                },\n            }\n            bundle_entries.append(entry)\n\n        bundle = {\n            \"resourceType\": \"Bundle\",\n            \"id\": bundle_id,\n            \"type\": bundle_type,\n            \"timestamp\": self._current_timestamp(),\n            \"entry\": bundle_entries,\n        }\n\n        return bundle\n\n    @staticmethod\n    def _generate_id() -&gt; str:\n        \"\"\"Generate a unique ID.\"\"\"\n        return str(uuid.uuid4())\n\n    @staticmethod\n    def _current_timestamp() -&gt; str:\n        \"\"\"Get the current timestamp in ISO format.\"\"\"\n\n        return datetime.now(UTC).isoformat()\n\n    @staticmethod\n    def _apply_metadata(resource: dict[str, Any], ruleset: RuleSet, rule: Rule) -&gt; None:\n        \"\"\"Apply metadata configuration to a resource.\n\n        Merges global_meta from ruleset and meta from rule.\n        Rule-level metadata takes precedence over ruleset-level.\n\n        Args:\n            resource: The resource dict to modify\n            ruleset: The ruleset containing global_meta\n            rule: The rule containing rule-specific meta\n        \"\"\"\n        # Collect all metadata configs (global first, then rule-specific)\n        meta_configs: list[MetaConfig] = []\n        if ruleset.global_meta:\n            meta_configs.append(ruleset.global_meta)\n        if rule.meta:\n            meta_configs.append(rule.meta)\n\n        if not meta_configs:\n            return\n\n        # Initialize meta if it doesn't exist\n        meta = resource.setdefault(\"meta\", {})\n\n        # Apply each config in order (later ones override earlier ones)\n        for config in meta_configs:\n            if config.security:\n                # Merge security labels\n                existing = meta.get(\"security\", [])\n                meta[\"security\"] = existing + config.security\n\n            if config.tag:\n                # Merge tags\n                existing = meta.get(\"tag\", [])\n                meta[\"tag\"] = existing + config.tag\n\n            if config.profile:\n                # Merge profiles\n                existing = meta.get(\"profile\", [])\n                meta[\"profile\"] = existing + config.profile\n\n            if config.source:\n                meta[\"source\"] = config.source\n\n            if config.versionId:\n                meta[\"versionId\"] = config.versionId\n\n            if config.lastUpdated:\n                meta[\"lastUpdated\"] = config.lastUpdated\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleEngine.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the rule engine.</p> Source code in <code>src/fhir_synth/rule_engine/engine.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the rule engine.\"\"\"\n    self.rulesets: dict[str, RuleSet] = {}\n    self.executors: dict[str, Callable[[Rule, dict[str, Any]], Any]] = {}\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleEngine.register_ruleset","title":"<code>register_ruleset(ruleset)</code>","text":"<p>Register a ruleset for a resource type.</p> Source code in <code>src/fhir_synth/rule_engine/engine.py</code> <pre><code>def register_ruleset(self, ruleset: RuleSet) -&gt; None:\n    \"\"\"Register a ruleset for a resource type.\"\"\"\n    self.rulesets[ruleset.resource_type] = ruleset\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleEngine.register_executor","title":"<code>register_executor(resource_type, executor)</code>","text":"<p>Register a custom executor function for a resource type.</p> Source code in <code>src/fhir_synth/rule_engine/engine.py</code> <pre><code>def register_executor(\n    self, resource_type: str, executor: Callable[[Rule, dict[str, Any]], Any]\n) -&gt; None:\n    \"\"\"Register a custom executor function for a resource type.\"\"\"\n    self.executors[resource_type] = executor\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleEngine.execute","title":"<code>execute(resource_type, context, count=1)</code>","text":"<p>Execute rules to generate resources.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>FHIR resource type to generate</p> required <code>context</code> <code>dict[str, Any]</code> <p>Context data for rule evaluation</p> required <code>count</code> <code>int</code> <p>Number of resources to generate</p> <code>1</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of generated resources</p> Source code in <code>src/fhir_synth/rule_engine/engine.py</code> <pre><code>def execute(\n    self,\n    resource_type: str,\n    context: dict[str, Any],\n    count: int = 1,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute rules to generate resources.\n\n    Args:\n        resource_type: FHIR resource type to generate\n        context: Context data for rule evaluation\n        count: Number of resources to generate\n\n    Returns:\n        List of generated resources\n    \"\"\"\n    if resource_type not in self.rulesets:\n        raise ValueError(f\"No ruleset registered for {resource_type}\")\n\n    ruleset = self.rulesets[resource_type]\n    executor = self.executors.get(resource_type)\n    results = []\n\n    for _ in range(count):\n        # Select rule based on conditions and weights\n        rule = self._select_rule(ruleset, context)\n\n        # Execute the rule\n        if executor:\n            resource = executor(rule, context)\n        else:\n            resource = self._default_executor(rule, context, resource_type)\n\n        # Apply metadata from ruleset and rule\n        self._apply_metadata(resource, ruleset, rule)\n\n        results.append(resource)\n\n    return results\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleEngine.generate_bundle","title":"<code>generate_bundle(resource_type, resources, bundle_type='transaction')</code>","text":"<p>Create a FHIR Bundle from resources.</p> <p>Parameters:</p> Name Type Description Default <code>resource_type</code> <code>str</code> <p>Expected resourceType for all bundled resources</p> required <code>resources</code> <code>list[dict[str, Any]]</code> <p>List of resources to bundle</p> required <code>bundle_type</code> <code>str</code> <p>Bundle type (transaction, batch, searchset, etc.)</p> <code>'transaction'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>FHIR Bundle resource</p> Source code in <code>src/fhir_synth/rule_engine/engine.py</code> <pre><code>def generate_bundle(\n    self,\n    resource_type: str,\n    resources: list[dict[str, Any]],\n    bundle_type: str = \"transaction\",\n) -&gt; dict[str, Any]:\n    \"\"\"Create a FHIR Bundle from resources.\n\n    Args:\n        resource_type: Expected resourceType for all bundled resources\n        resources: List of resources to bundle\n        bundle_type: Bundle type (transaction, batch, searchset, etc.)\n\n    Returns:\n        FHIR Bundle resource\n    \"\"\"\n    for resource in resources:\n        if resource.get(\"resourceType\") != resource_type:\n            raise ValueError(\n                \"All resources must match resource_type; \"\n                f\"expected '{resource_type}', got '{resource.get('resourceType')}'\"\n            )\n    bundle_id = self._generate_id()\n    bundle_entries = []\n\n    for resource in resources:\n        entry = {\n            \"fullUrl\": f\"urn:uuid:{self._generate_id()}\",\n            \"resource\": resource,\n            \"request\": {\n                \"method\": \"POST\",\n                \"url\": resource.get(\"resourceType\", \"\"),\n            },\n        }\n        bundle_entries.append(entry)\n\n    bundle = {\n        \"resourceType\": \"Bundle\",\n        \"id\": bundle_id,\n        \"type\": bundle_type,\n        \"timestamp\": self._current_timestamp(),\n        \"entry\": bundle_entries,\n    }\n\n    return bundle\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.MetaConfig","title":"<code>MetaConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for FHIR resource metadata.</p> <p>Allows setting security labels, tags, profiles, and other metadata elements.</p> Source code in <code>src/fhir_synth/rule_engine/models.py</code> <pre><code>class MetaConfig(BaseModel):\n    \"\"\"Configuration for FHIR resource metadata.\n\n    Allows setting security labels, tags, profiles, and other metadata elements.\n    \"\"\"\n\n    security: list[dict[str, Any]] | None = Field(\n        default=None,\n        description=\"Security labels (e.g., confidentiality, sensitivity)\",\n    )\n    tag: list[dict[str, Any]] | None = Field(\n        default=None,\n        description=\"Tags for operational/workflow purposes\",\n    )\n    profile: list[str] | None = Field(\n        default=None,\n        description=\"Profile URLs this resource claims to conform to\",\n    )\n    source: str | None = Field(\n        default=None,\n        description=\"Source system URI\",\n    )\n    versionId: str | None = Field(\n        default=None,\n        description=\"Version-specific identifier\",\n    )\n    lastUpdated: str | None = Field(\n        default=None,\n        description=\"Last updated timestamp (ISO 8601)\",\n    )\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.Rule","title":"<code>Rule</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Single rule for resource generation.</p> Source code in <code>src/fhir_synth/rule_engine/models.py</code> <pre><code>class Rule(BaseModel):\n    \"\"\"Single rule for resource generation.\"\"\"\n\n    name: str = Field(description=\"Rule name\")\n    description: str = Field(description=\"What this rule does\")\n    conditions: dict[str, Any] = Field(default_factory=dict, description=\"Conditions to check\")\n    actions: dict[str, Any] = Field(default_factory=dict, description=\"Actions to execute\")\n    weight: float = Field(default=1.0, ge=0.0, description=\"Probability weight for this rule\")\n    meta: MetaConfig | None = Field(\n        default=None,\n        description=\"Custom metadata (security tags, profiles, etc.)\",\n    )\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.RuleSet","title":"<code>RuleSet</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection of rules for a resource type.</p> <p><code>resource_type</code> is validated against all known FHIR R4B types.</p> Source code in <code>src/fhir_synth/rule_engine/models.py</code> <pre><code>class RuleSet(BaseModel):\n    \"\"\"Collection of rules for a resource type.\n\n    ``resource_type`` is validated against all known FHIR R4B types.\n    \"\"\"\n\n    resource_type: str = Field(description=\"FHIR resource type (e.g., Patient, Condition)\")\n    description: str = Field(description=\"What resources this ruleset generates\")\n    rules: list[Rule] = Field(default_factory=list, description=\"List of rules\")\n    default_rule: Rule | None = Field(\n        default=None, description=\"Default rule if no conditions match\"\n    )\n    bundle_config: dict[str, Any] = Field(\n        default_factory=dict,\n        description=\"Config for bundling multiple resources\",\n    )\n    global_meta: MetaConfig | None = Field(\n        default=None,\n        description=\"Global metadata applied to all resources from this ruleset\",\n    )\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules","title":"<code>GenerationRules</code>  <code>dataclass</code>","text":"<p>Generic declarative rules for synthetic data generation.</p> <p>Rules are stored in a single <code>rules_by_type</code> dict keyed by FHIR resource type name (e.g. <code>\"Patient\"</code>, <code>\"Immunization\"</code>). This supports any of the 141 FHIR R4B resource types.</p> Source code in <code>src/fhir_synth/rule_engine/rules.py</code> <pre><code>@dataclass\nclass GenerationRules:\n    \"\"\"Generic declarative rules for synthetic data generation.\n\n    Rules are stored in a single ``rules_by_type`` dict keyed by FHIR\n    resource type name (e.g. ``\"Patient\"``, ``\"Immunization\"``).\n    This supports any of the 141 FHIR R4B resource types.\n    \"\"\"\n\n    population: dict[str, Any] = field(default_factory=dict)\n    \"\"\"High-level population config (e.g. count, demographics).\"\"\"\n\n    rules_by_type: dict[str, list[Rule]] = field(default_factory=dict)\n    \"\"\"Rules keyed by FHIR resource type \u2014 works for any of the 141 R4B types.\"\"\"\n\n    def add_rules(self, resource_type: str, rules: list[Rule]) -&gt; None:\n        \"\"\"Add rules for a resource type.\"\"\"\n        self.rules_by_type.setdefault(resource_type, []).extend(rules)\n\n    def get_rules(self, resource_type: str) -&gt; list[Rule]:\n        \"\"\"Get rules for a resource type.\"\"\"\n        return self.rules_by_type.get(resource_type, [])\n\n    @property\n    def resource_types(self) -&gt; list[str]:\n        \"\"\"Return all resource types that have rules defined.\"\"\"\n        return list(self.rules_by_type.keys())\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert rules to dictionary.\"\"\"\n        return {\n            \"population\": self.population,\n            \"rules_by_type\": {\n                rt: [r.model_dump() for r in rules] for rt, rules in self.rules_by_type.items()\n            },\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -&gt; \"GenerationRules\":\n        \"\"\"Create rules from a dictionary.\"\"\"\n        rules_by_type: dict[str, list[Rule]] = {}\n        for rt, rule_list in data.get(\"rules_by_type\", {}).items():\n            rules_by_type[rt] = [Rule(**r) for r in rule_list]\n\n        return cls(\n            population=data.get(\"population\", {}),\n            rules_by_type=rules_by_type,\n        )\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.population","title":"<code>population = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>High-level population config (e.g. count, demographics).</p>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.rules_by_type","title":"<code>rules_by_type = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rules keyed by FHIR resource type \u2014 works for any of the 141 R4B types.</p>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.resource_types","title":"<code>resource_types</code>  <code>property</code>","text":"<p>Return all resource types that have rules defined.</p>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.add_rules","title":"<code>add_rules(resource_type, rules)</code>","text":"<p>Add rules for a resource type.</p> Source code in <code>src/fhir_synth/rule_engine/rules.py</code> <pre><code>def add_rules(self, resource_type: str, rules: list[Rule]) -&gt; None:\n    \"\"\"Add rules for a resource type.\"\"\"\n    self.rules_by_type.setdefault(resource_type, []).extend(rules)\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.get_rules","title":"<code>get_rules(resource_type)</code>","text":"<p>Get rules for a resource type.</p> Source code in <code>src/fhir_synth/rule_engine/rules.py</code> <pre><code>def get_rules(self, resource_type: str) -&gt; list[Rule]:\n    \"\"\"Get rules for a resource type.\"\"\"\n    return self.rules_by_type.get(resource_type, [])\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert rules to dictionary.</p> Source code in <code>src/fhir_synth/rule_engine/rules.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert rules to dictionary.\"\"\"\n    return {\n        \"population\": self.population,\n        \"rules_by_type\": {\n            rt: [r.model_dump() for r in rules] for rt, rules in self.rules_by_type.items()\n        },\n    }\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.GenerationRules.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create rules from a dictionary.</p> Source code in <code>src/fhir_synth/rule_engine/rules.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"GenerationRules\":\n    \"\"\"Create rules from a dictionary.\"\"\"\n    rules_by_type: dict[str, list[Rule]] = {}\n    for rt, rule_list in data.get(\"rules_by_type\", {}).items():\n        rules_by_type[rt] = [Rule(**r) for r in rule_list]\n\n    return cls(\n        population=data.get(\"population\", {}),\n        rules_by_type=rules_by_type,\n    )\n</code></pre>"},{"location":"api/rule_engine/#fhir_synth.rule_engine.generate_empi_resources","title":"<code>generate_empi_resources(persons, systems=None, include_organizations=True)</code>","text":"<p>Generate EMPI-style Person and Patient resources.</p> <p>Each Person is linked to one Patient per source system (EMR). Optionally creates Organization resources for each system and links Patients to them.</p> <p>Parameters:</p> Name Type Description Default <code>persons</code> <code>int</code> <p>Number of Person resources to generate</p> required <code>systems</code> <code>list[str] | None</code> <p>Source system identifiers (e.g., [\"emr1\", \"emr2\"])</p> <code>None</code> <code>include_organizations</code> <code>bool</code> <p>Whether to create Organization resources</p> <code>True</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of FHIR resources (Organization, Person, Patient)</p> Source code in <code>src/fhir_synth/rule_engine/empi.py</code> <pre><code>def generate_empi_resources(\n    persons: int,\n    systems: list[str] | None = None,\n    include_organizations: bool = True,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Generate EMPI-style Person and Patient resources.\n\n    Each Person is linked to one Patient per source system (EMR). Optionally\n    creates Organization resources for each system and links Patients to them.\n\n    Args:\n        persons: Number of Person resources to generate\n        systems: Source system identifiers (e.g., [\"emr1\", \"emr2\"])\n        include_organizations: Whether to create Organization resources\n\n    Returns:\n        List of FHIR resources (Organization, Person, Patient)\n    \"\"\"\n    if persons &lt; 1:\n        raise ValueError(\"persons must be &gt;= 1\")\n\n    systems = systems or [\"emr1\", \"emr2\"]\n    resources: list[dict[str, Any]] = []\n\n    organizations: dict[str, dict[str, Any]] = {}\n    if include_organizations:\n        for system in systems:\n            org_id = f\"org-{system}\"\n            organizations[system] = {\n                \"resourceType\": \"Organization\",\n                \"id\": org_id,\n                \"name\": system,\n                \"identifier\": [{\"system\": \"urn:emr\", \"value\": system}],\n            }\n        resources.extend(organizations.values())\n\n    for i in range(1, persons + 1):\n        person_id = f\"person-{i}\"\n        person_links = []\n        patient_resources = []\n\n        for system in systems:\n            patient_id = f\"{system}-patient-{i}\"\n            patient_resource: dict[str, Any] = {\n                \"resourceType\": \"Patient\",\n                \"id\": patient_id,\n                \"identifier\": [{\"system\": f\"urn:emr:{system}\", \"value\": patient_id}],\n            }\n            if include_organizations:\n                patient_resource[\"managingOrganization\"] = {\n                    \"reference\": f\"Organization/{organizations[system]['id']}\"\n                }\n            patient_resources.append(patient_resource)\n            person_links.append({\"target\": {\"reference\": f\"Patient/{patient_id}\"}})\n\n        person_resource = {\n            \"resourceType\": \"Person\",\n            \"id\": person_id,\n            \"link\": person_links,\n        }\n\n        resources.append(person_resource)\n        resources.extend(patient_resources)\n\n    return resources\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>An LLM API key (OpenAI, Anthropic, etc.) \u2014 or use <code>--provider mock</code> for testing</li> </ul>"},{"location":"getting-started/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install fhir-synth\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":"<pre><code>git clone https://github.com/alvinhenrick/fhir-synth.git\ncd fhir-synth\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/installation/#set-up-your-llm-provider","title":"Set Up Your LLM Provider","text":"<p>Create a <code>.env</code> file in your project root with your API key:</p> <pre><code># OpenAI\nOPENAI_API_KEY=sk-...\n\n# Anthropic\nANTHROPIC_API_KEY=sk-ant-...\n\n# Or any provider supported by LiteLLM\n</code></pre> <p>No API Key?</p> <p>Use <code>--provider mock</code> to test without any API key. The mock provider returns hardcoded sample resources.</p>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>fhir-synth --help\n</code></pre> <p>You should see the available commands: <code>generate</code>, <code>rules</code>, <code>codegen</code>, <code>bundle</code>.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":""},{"location":"getting-started/quickstart/#generate-data-from-a-prompt","title":"Generate Data from a Prompt","text":"<p>Describe what you need in plain English \u2014 FHIR Synth generates the code and executes it:</p> <pre><code># 10 diabetic patients with labs \u2192 single bundle + NDJSON\nfhir-synth generate \"10 diabetic patients with HbA1c observations\" -o diabetes.json\n\n# Split: one file per patient + NDJSON\nfhir-synth generate \"10 diabetic patients with HbA1c observations\" --split -o patients/\n\n# 5 patients with hypertension, encounters, and meds\nfhir-synth generate \"5 patients with hypertension, office encounters, and antihypertensive medications\" -o hypertension.json\n</code></pre>"},{"location":"getting-started/quickstart/#what-happens-under-the-hood","title":"What Happens Under the Hood","text":"<ol> <li>Your prompt goes to the LLM</li> <li>LLM generates Python code using <code>fhir.resources</code> (Pydantic FHIR models)</li> <li>Code is executed in a sandbox</li> <li>If it fails, the error is sent back to the LLM for self-healing (up to 2 retries)</li> <li>Resources are wrapped in a FHIR R4B Bundle and saved</li> </ol>"},{"location":"getting-started/quickstart/#save-generated-code","title":"Save Generated Code","text":"<p>Inspect the code the LLM generates:</p> <pre><code>fhir-synth generate \"20 patients with conditions\" -o data.json --save-code generated.py\n</code></pre>"},{"location":"getting-started/quickstart/#empi-mode","title":"EMPI Mode","text":"<p>Generate Person \u2192 Patient linkages across EMR systems:</p> <pre><code>fhir-synth generate \"EMPI dataset\" --empi --persons 3 -o empi.json\n</code></pre>"},{"location":"getting-started/quickstart/#use-the-python-api","title":"Use the Python API","text":"<pre><code>from fhir_synth.llm import get_provider\nfrom fhir_synth.code_generator import CodeGenerator\nfrom fhir_synth.bundle import BundleBuilder\n\n# Generate code from prompts\nllm = get_provider(\"mock\")\ncode_gen = CodeGenerator(llm)\ncode = code_gen.generate_code_from_prompt(\"Create 20 patients\")\nresources = code_gen.execute_generated_code(code)\n\n# Build a FHIR bundle\nbuilder = BundleBuilder(bundle_type=\"transaction\")\nbuilder.add_resources(resources)\nbundle = builder.build()\n</code></pre>"},{"location":"getting-started/quickstart/#add-custom-metadata","title":"Add Custom Metadata","text":"<p>Apply security labels, tags, and profiles via YAML:</p> <pre><code># meta-normal.yaml\nmeta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"R\"\n      display: \"Restricted\"\n  tag:\n    - system: \"http://example.org/tags\"\n      code: \"synthetic-data\"\n  source: \"http://example.org/fhir-synth\"\n</code></pre> <pre><code>fhir-synth generate \"20 patients\" --meta-config examples/meta-normal.yaml -o output.json\n</code></pre>"},{"location":"getting-started/quickstart/#test-without-an-api-key","title":"Test Without an API Key","text":"<pre><code>fhir-synth generate \"5 patients\" --provider mock -o test.json\n</code></pre>"},{"location":"guide/api/","title":"Python API","text":"<p>Use FHIR Synth as a library in your Python code.</p>"},{"location":"guide/api/#code-generation","title":"Code Generation","text":"<pre><code>from fhir_synth.llm import get_provider\nfrom fhir_synth.code_generator import CodeGenerator\n\n# Set up LLM provider\nllm = get_provider(\"gpt-4\")  # or \"mock\" for testing\n\n# Generate and execute code\ncode_gen = CodeGenerator(llm)\ncode = code_gen.generate_code_from_prompt(\"Create 20 diabetic patients with HbA1c observations\")\nresources = code_gen.execute_generated_code(code)\n</code></pre>"},{"location":"guide/api/#rule-engine","title":"Rule Engine","text":"<pre><code>from fhir_synth.rule_engine import RuleEngine, Rule, RuleSet, MetaConfig\n\nengine = RuleEngine()\nengine.register_ruleset(\n    RuleSet(\n        resource_type=\"Patient\",\n        description=\"Diabetic patients\",\n        global_meta=MetaConfig(\n            tag=[{\"system\": \"http://example.org/tags\", \"code\": \"synthetic\"}],\n            source=\"http://example.org/fhir-synth\",\n        ),\n        rules=[\n            Rule(\n                name=\"type_2\",\n                description=\"Type 2 diabetes\",\n                conditions={\"type\": 2},\n                actions={\"resourceType\": \"Patient\", \"id\": \"p1\"},\n                weight=1.0,\n                meta=MetaConfig(\n                    security=[{\n                        \"system\": \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\",\n                        \"code\": \"N\",\n                        \"display\": \"Normal\",\n                    }],\n                    profile=[\"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"],\n                ),\n            )\n        ],\n    )\n)\n</code></pre>"},{"location":"guide/api/#bundle-building","title":"Bundle Building","text":"<pre><code>from fhir_synth.bundle import BundleBuilder, BundleManager\n\n# Build a single bundle from resources\nbuilder = BundleBuilder(bundle_type=\"transaction\")\nbuilder.add_resources(resources)\nbundle = builder.build()\n\n# Save to file\nBundleManager.save(bundle, \"output.json\")\n</code></pre>"},{"location":"guide/api/#split-per-patient-ndjson","title":"Split Per Patient &amp; NDJSON","text":"<pre><code>from pathlib import Path\nfrom fhir_synth.bundle import split_resources_by_patient, write_split_bundles, write_ndjson\n\n# Split resources into one bundle per patient\nper_patient = split_resources_by_patient(resources)\n\n# Write one JSON file per patient\nwrite_split_bundles(per_patient, Path(\"patients/\"))\n# \u2192 patients/patient_001.json, patients/patient_002.json, ...\n\n# Write NDJSON (one bundle per line)\nwrite_ndjson(per_patient, Path(\"patients.ndjson\"))\n</code></pre>"},{"location":"guide/api/#fhir-resource-factory","title":"FHIR Resource Factory","text":"<pre><code>from fhir_synth.fhir_utils import FHIRResourceFactory\n\n# Create resources directly\npatient = FHIRResourceFactory.create_patient(\"p1\", \"Jane\", \"Doe\", \"1990-01-01\")\n</code></pre>"},{"location":"guide/api/#custom-metadata","title":"Custom Metadata","text":"<pre><code>from fhir_synth.rule_engine import MetaConfig\n\nmeta = MetaConfig(\n    security=[{\n        \"system\": \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\",\n        \"code\": \"R\",\n        \"display\": \"Restricted\",\n    }],\n    tag=[{\"system\": \"http://example.org/tags\", \"code\": \"synthetic-data\"}],\n    profile=[\"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"],\n    source=\"http://example.org/fhir-synth\",\n)\n</code></pre>"},{"location":"guide/cli/","title":"CLI Reference","text":""},{"location":"guide/cli/#fhir-synth-generate","title":"<code>fhir-synth generate</code>","text":"<p>End-to-end: prompt \u2192 LLM \u2192 code \u2192 execute \u2192 FHIR Bundle.</p> <pre><code>fhir-synth generate \"10 diabetic patients with HbA1c observations\" -o diabetes.json\n</code></pre>"},{"location":"guide/cli/#options","title":"Options","text":"Flag Default Description <code>-o / --out</code> <code>output.json</code> Output file (or directory with <code>--split</code>) <code>-p / --provider</code> <code>gpt-4</code> LLM model/provider <code>-t / --type</code> <code>transaction</code> Bundle type <code>--split</code> off Split output: one JSON file per patient <code>--save-code</code> \u2014 Save generated Python code <code>--empi</code> off Include EMPI Person\u2192Patient linkage <code>--persons</code> <code>1</code> Number of Persons (EMPI) <code>--systems</code> <code>emr1,emr2</code> EMR system ids (EMPI) <code>--no-orgs</code> off Skip Organization resources (EMPI) <code>--meta-config</code> \u2014 Path to metadata YAML config file <p>NDJSON output (one patient bundle per line) is always generated alongside the JSON output.</p>"},{"location":"guide/cli/#examples","title":"Examples","text":"<pre><code># Single bundle (default) \u2192 output.json + output.ndjson\nfhir-synth generate \"10 diabetic patients with HbA1c observations\" -o diabetes.json\n\n# Split per patient \u2192 patients/patient_001.json ... + patients/all_patients.ndjson\nfhir-synth generate \"10 diabetic patients with HbA1c observations\" --split -o patients/\n\n# With EMPI\nfhir-synth generate \"EMPI dataset\" --empi --persons 3 -o empi.json\n\n# With metadata from YAML\nfhir-synth generate \"20 patients\" --meta-config examples/meta-normal.yaml -o output.json\n\n# Save generated code for inspection\nfhir-synth generate \"20 patients with conditions\" -o data.json --save-code generated.py\n\n# Mock provider (no API key needed)\nfhir-synth generate \"5 patients\" --provider mock -o test.json\n</code></pre>"},{"location":"guide/cli/#fhir-synth-rules","title":"<code>fhir-synth rules</code>","text":"<p>Generate structured rule definitions from natural language.</p> <pre><code>fhir-synth rules \"100 diabetic patients with insulin therapy\" --out rules.json --provider gpt-4\n</code></pre>"},{"location":"guide/cli/#fhir-synth-codegen","title":"<code>fhir-synth codegen</code>","text":"<p>Generate executable Python code from prompts (without bundling).</p> <pre><code>fhir-synth codegen \"Create 50 patients\" --out code.py\nfhir-synth codegen \"Create 50 patients\" --out code.py --execute\n</code></pre>"},{"location":"guide/cli/#fhir-synth-bundle","title":"<code>fhir-synth bundle</code>","text":"<p>Create FHIR R4B Bundles from NDJSON data or EMPI defaults.</p> <pre><code>fhir-synth bundle --resources data.ndjson --out bundle.json --type transaction\nfhir-synth bundle --empi --persons 5 --systems emr1,emr2,emr3 --no-orgs --out empi_bundle.json\n</code></pre>"},{"location":"guide/metadata-reference/","title":"Metadata Quick Reference","text":""},{"location":"guide/metadata-reference/#yaml-config-file","title":"YAML Config File","text":"<p>Create a reusable YAML config file and use it with <code>--meta-config</code>:</p> <p>meta-normal.yaml: <pre><code>meta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"N\"\n      display: \"Normal\"\n  tag:\n    - system: \"http://example.org/tags\"\n      code: \"synthetic-data\"\n      display: \"Synthetic Test Data\"\n  profile:\n    - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n  source: \"http://example.org/fhir-synth\"\n</code></pre></p> <p>Usage: <pre><code>fhir-synth generate \"10 diabetic patients\" --meta-config examples/meta-normal.yaml -o output.json\n</code></pre></p> <p>LLM-Powered Metadata</p> <p>You can also describe metadata in your prompt \u2014 the LLM understands requests like \"10 HIV patients with restricted security labels\" and generates code with <code>Meta</code> and <code>Coding</code> models.</p>"},{"location":"guide/metadata-reference/#common-metadata-patterns","title":"Common Metadata Patterns","text":""},{"location":"guide/metadata-reference/#security-labels-confidentiality","title":"Security Labels (Confidentiality)","text":"<pre><code># Normal confidentiality\nsecurity:\n  - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n    code: \"N\"\n    display: \"Normal\"\n\n# Restricted access\nsecurity:\n  - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n    code: \"R\"\n    display: \"Restricted\"\n\n# Very restricted (sensitive)\nsecurity:\n  - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n    code: \"V\"\n    display: \"Very restricted\"\n</code></pre>"},{"location":"guide/metadata-reference/#tags-classification","title":"Tags (Classification)","text":"<pre><code># Synthetic data tag\ntag:\n  - system: \"http://example.org/tags\"\n    code: \"synthetic-data\"\n    display: \"Synthetic Test Data\"\n\n# Study enrollment tag\ntag:\n  - system: \"http://example.org/study\"\n    code: \"STUDY-2026-001\"\n    display: \"Clinical Study 2026-001\"\n\n# Data classification tag\ntag:\n  - system: \"http://example.org/data-classification\"\n    code: \"test-only\"\n    display: \"Test Data Only\"\n</code></pre>"},{"location":"guide/metadata-reference/#profiles-conformance","title":"Profiles (Conformance)","text":"<pre><code># US Core Patient\nprofile:\n  - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n\n# US Core Condition\nprofile:\n  - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition\"\n\n# US Core Observation\nprofile:\n  - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-observation\"\n\n# Multiple profiles\nprofile:\n  - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n  - \"http://example.org/fhir/StructureDefinition/research-patient\"\n</code></pre>"},{"location":"guide/metadata-reference/#source-system","title":"Source System","text":"<pre><code># EHR system\nsource: \"http://hospital-ehr.example.org/fhir\"\n\n# Lab system\nsource: \"http://lab-system.example.org/fhir\"\n\n# Research database\nsource: \"http://research-db.example.org/fhir\"\n</code></pre>"},{"location":"guide/metadata-reference/#version-tracking","title":"Version Tracking","text":"<pre><code># Version and timestamp\nversionId: \"v2.1\"\nlastUpdated: \"2026-02-23T12:00:00Z\"\n</code></pre>"},{"location":"guide/metadata-reference/#example-metadata-configs","title":"Example Metadata Configs","text":""},{"location":"guide/metadata-reference/#examplesmeta-normalyaml-normal-confidentiality","title":"examples/meta-normal.yaml (Normal Confidentiality)","text":"<pre><code>meta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"N\"\n      display: \"Normal\"\n  tag:\n    - system: \"http://example.org/tags\"\n      code: \"synthetic-data\"\n      display: \"Synthetic Test Data\"\n  profile:\n    - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n  source: \"http://example.org/fhir-synth\"\n</code></pre> <p>Usage: <pre><code>fhir-synth generate \"20 patients with diabetes\" --meta-config examples/meta-normal.yaml -o output.json\n</code></pre></p>"},{"location":"guide/metadata-reference/#examplesmeta-restrictedyaml-sensitive-data","title":"examples/meta-restricted.yaml (Sensitive Data)","text":"<pre><code>meta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"R\"\n      display: \"Restricted\"\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-ActCode\"\n      code: \"HIV\"\n      display: \"HIV/AIDS Information\"\n  tag:\n    - system: \"http://example.org/data-classification\"\n      code: \"sensitive\"\n      display: \"Sensitive Information\"\n  profile:\n    - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-condition\"\n  source: \"http://hospital-ehr.example.org/fhir\"\n</code></pre> <p>Usage: <pre><code>fhir-synth generate \"10 HIV patients\" --meta-config examples/meta-restricted.yaml -o hiv.json\n</code></pre></p>"},{"location":"guide/metadata-reference/#output-example","title":"Output Example","text":"<pre><code>{\n  \"resourceType\": \"Patient\",\n  \"id\": \"abc-123\",\n  \"name\": [{\"family\": \"Smith\", \"given\": [\"John\"]}],\n  \"meta\": {\n    \"security\": [\n      {\n        \"system\": \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\",\n        \"code\": \"N\",\n        \"display\": \"Normal\"\n      }\n    ],\n    \"tag\": [\n      {\n        \"system\": \"http://example.org/study\",\n        \"code\": \"DIABETES-2026\",\n        \"display\": \"Diabetes Study 2026\"\n      }\n    ],\n    \"profile\": [\n      \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n    ],\n    \"source\": \"http://hospital.example.org/fhir\"\n  }\n}\n</code></pre>"},{"location":"guide/metadata-reference/#more-examples","title":"More Examples","text":"<p>See: - <code>examples/meta-normal.yaml</code> \u2014 Normal confidentiality config - <code>examples/meta-restricted.yaml</code> \u2014 Restricted security for sensitive data</p>"},{"location":"guide/metadata/","title":"Metadata Configuration","text":"<p>Add security labels, tags, profiles, and other FHIR metadata to generated resources.</p>"},{"location":"guide/metadata/#yaml-configuration","title":"YAML Configuration","text":"<p>Create a metadata YAML file and pass it to the <code>generate</code> command:</p> <pre><code># meta-normal.yaml\nmeta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"N\"\n      display: \"Normal\"\n  tag:\n    - system: \"http://example.org/tags\"\n      code: \"synthetic-data\"\n      display: \"Synthetic Test Data\"\n  profile:\n    - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n  source: \"http://example.org/fhir-synth\"\n</code></pre> <pre><code>fhir-synth generate \"20 patients with conditions\" --meta-config examples/meta-normal.yaml -o output.json\n</code></pre>"},{"location":"guide/metadata/#supported-fields","title":"Supported Fields","text":"YAML Key Description <code>security</code> Security labels (confidentiality, sensitivity) \u2014 list of <code>{system, code, display}</code> <code>tag</code> Tags for operational/workflow purposes \u2014 list of <code>{system, code, display}</code> <code>profile</code> Profile URLs the resource conforms to \u2014 list of URL strings <code>source</code> Source system URI \u2014 string"},{"location":"guide/metadata/#restricted-data-example","title":"Restricted Data Example","text":"<pre><code># meta-restricted.yaml\nmeta:\n  security:\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\"\n      code: \"R\"\n      display: \"Restricted\"\n    - system: \"http://terminology.hl7.org/CodeSystem/v3-ActCode\"\n      code: \"ETH\"\n      display: \"Substance Abuse Related\"\n  tag:\n    - system: \"http://example.org/tags\"\n      code: \"restricted-synthetic\"\n      display: \"Restricted Synthetic Data\"\n  profile:\n    - \"http://hl7.org/fhir/us/core/StructureDefinition/us-core-patient\"\n  source: \"http://example.org/fhir-synth/restricted\"\n</code></pre>"},{"location":"guide/metadata/#rule-engine-metadata","title":"Rule Engine Metadata","text":"<p>When using the Rule Engine, metadata can be applied at two levels:</p> <ul> <li><code>global_meta</code> \u2014 Applied to all resources in a RuleSet</li> <li><code>meta</code> (per rule) \u2014 Applied to resources generated by that specific rule</li> </ul> <p>Rule-specific metadata is merged with global metadata, with rule-specific values taking precedence.</p> <pre><code>from fhir_synth.rule_engine import RuleSet, Rule, MetaConfig\n\nruleset = RuleSet(\n    resource_type=\"Patient\",\n    description=\"Example\",\n    global_meta=MetaConfig(\n        tag=[{\"system\": \"http://example.org/tags\", \"code\": \"synthetic\"}],\n    ),\n    rules=[\n        Rule(\n            name=\"rule1\",\n            description=\"Example rule\",\n            conditions={},\n            actions={\"resourceType\": \"Patient\"},\n            weight=1.0,\n            meta=MetaConfig(\n                security=[{\n                    \"system\": \"http://terminology.hl7.org/CodeSystem/v3-Confidentiality\",\n                    \"code\": \"N\",\n                }],\n            ),\n        )\n    ],\n)\n</code></pre>"},{"location":"guide/providers/","title":"LLM Providers","text":"<p>FHIR Synth uses LiteLLM to support 100+ LLM providers.</p>"},{"location":"guide/providers/#supported-providers","title":"Supported Providers","text":"Provider Model Example Env Variable OpenAI <code>gpt-4</code>, <code>gpt-4o</code>, <code>gpt-3.5-turbo</code> <code>OPENAI_API_KEY</code> Anthropic <code>claude-3-opus-20240229</code> <code>ANTHROPIC_API_KEY</code> AWS Bedrock <code>bedrock/anthropic.claude-v2</code> AWS credentials Azure OpenAI <code>azure/gpt-4</code> <code>AZURE_API_KEY</code> Google <code>gemini/gemini-pro</code> <code>GEMINI_API_KEY</code> <p>See LiteLLM docs for the full list.</p>"},{"location":"guide/providers/#configuration","title":"Configuration","text":"<p>Set your API key in a <code>.env</code> file:</p> <pre><code># OpenAI (default)\nOPENAI_API_KEY=sk-...\n\n# Anthropic\nANTHROPIC_API_KEY=sk-ant-...\n</code></pre>"},{"location":"guide/providers/#usage","title":"Usage","text":"<pre><code># OpenAI GPT-4 (default)\nfhir-synth generate \"10 patients\" -o output.json\n\n# Specify provider\nfhir-synth generate \"10 patients\" -p claude-3-opus-20240229 -o output.json\n\n# Mock provider for testing (no API key needed)\nfhir-synth generate \"5 patients\" --provider mock -o test.json\n</code></pre>"},{"location":"guide/providers/#mock-provider","title":"Mock Provider","text":"<p>The mock provider generates hardcoded sample resources without calling any API. Useful for:</p> <ul> <li>Testing without API keys</li> <li>CI/CD pipelines</li> <li>Development and debugging</li> </ul> <pre><code>fhir-synth generate \"5 patients\" --provider mock -o test.json\n</code></pre>"}]}